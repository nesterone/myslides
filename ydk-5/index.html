<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>You Don't Know JS - scope & closure</title>

		<meta name="description" content="scope & closure">
		<meta name="author" content="Igor Nesterenko">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.min.css">
		<link rel="stylesheet" href="css/theme/default.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', include the PDF print sheet -->
		<script>
			if( window.location.search.match( /print-pdf/gi ) ) {
				var link = document.createElement( 'link' );
				link.rel = 'stylesheet';
				link.type = 'text/css';
				link.href = 'css/print/pdf.css';
				document.getElementsByTagName( 'head' )[0].appendChild( link );
			}
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->

        <style type="text/css">
            .left-side {
                text-align: left;

            }
        </style>
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
                <section><h3 id="you-don-t-know-js-es6-beyond">You Don&#39;t Know JS:  ES6 &amp; Beyond</h3>
<h5 id="es6-beyond">es6 &amp; beyond</h5>
<p>inspired by <a href="https://github.com/getify/You-Dont-Know-JS/tree/master/async%20%26%20performance">getify</a></p>
</section><section><h3 id="presented-by">Presented by</h3>
<ul>
<li><a href="https://twitter.com/nesterone">Igor Nesterenko</a></li>
</ul>
</section><section><h2 id="high-level-overview">High-level Overview</h2>
<ul>
<li>Syntax</li>
<li>Organization</li>
<li>Async Flow Control</li>
<li>Collections</li>
<li>API Additions</li>
<li>Meta Programming</li>
<li>Beyond ES6</li>
</ul>
</section><section><h2 id="syntax">Syntax</h2>
<ul>
<li>Block-Scoped Declarations</li>
<li>Spread/Rest</li>
<li>Default Parameter Values</li>
<li>Destructuring</li>
<li>Object Literal Extensions</li>
<li>Template Literals</li>
<li>Arrow Functions</li>
<li><code>for..of</code> Loops</li>
<li>Regular Expressions</li>
<li>Number Literal Extensions</li>
<li>Symbols</li>
<li>Review</li>
</ul>
</section><section><h2 id="block-scoped-declarations">Block-Scoped Declarations</h2>
<p>Before</p>
<pre><code class="lang-js">var a = 2;

(function IIFE(){
    var a = 3;
    console.log( a );    // 3
})();

console.log( a );        // 2</code></pre>
</section><section><h3 id="-let-declarations"><code>let</code> Declarations</h3>
<pre><code class="lang-js">var a = 2;

{
    let a = 3;
    console.log( a );    // 3
}

console.log( a );        // 2</code></pre>
</section><section><h3 id="temporal-dead-zone-tdz-">Temporal Dead Zone (TDZ)</h3>
<pre><code class="lang-js">{
    console.log( a );    // undefined
    console.log( b );    // ReferenceError!

    var a;
    let b;
}</code></pre>
</section><section><h3 id="-typeof-gotcha"><code>typeof</code> gotcha</h3>
<pre><code class="lang-js">{
    // `a` is not declared
    if (typeof a === &quot;undefined&quot;) {
        console.log( &quot;cool&quot; );
    }

    // `b` is declared, but in its TDZ
    if (typeof b === &quot;undefined&quot;) {        // ReferenceError!
        // ..
    }

    // ..

    let b;
}</code></pre>
</section><section><h3 id="let-for">let + for</h3>
<pre><code class="lang-js">var funcs = [];

for (let i = 0; i &lt; 5; i++) {
    funcs.push( function(){
        console.log( i );
    } );
}

funcs[3]();        // 3</code></pre>
<p>More verbose </p>
<pre><code class="lang-js">var funcs = [];

for (var i = 0; i &lt; 5; i++) {
    let j = i;
    funcs.push( function(){
        console.log( j );
    } );
}

funcs[3]();        // 3</code></pre>
</section><section><h3 id="-const-declarations"><code>const</code> Declarations</h3>
<pre><code class="lang-js">{
    const a = 2;
    console.log( a );    // 2

    a = 3;                // TypeError!
}</code></pre>
<p>However </p>
<pre><code class="lang-js">{
    const a = [1,2,3];
    a.push( 4 );
    console.log( a );        // [1,2,3,4]

    a = 42;                    // TypeError!
}</code></pre>
</section><section><h3 id="-const-or-not"><code>const</code> Or Not</h3>
<ul>
<li>improvements in performance are questionable</li>
<li>source code is communicated clearly</li>
</ul>
</section><section><h3 id="block-scoped-functions">Block-scoped Functions</h3>
<pre><code class="lang-js">{
    foo();                    // works!

    function foo() {
        // ..
    }
}

foo();                        // ReferenceError</code></pre>
<ul>
<li>&quot;hoisted&quot; inside a block</li>
</ul>
</section><section><h3 id="pre-es6-and-es6-quiz">Pre-ES6 and ES6 quiz</h3>
<pre><code class="lang-js">if (something) {
    function foo() {
        console.log( &quot;1&quot; );
    }
}
else {
    function foo() {
        console.log( &quot;2&quot; );
    }
}

foo();        // ??</code></pre>
</section><section><h2 id="spread-rest">Spread/Rest</h2>
<pre><code class="lang-js">function foo(x,y,z) {
    console.log( x, y, z );
}

foo( ...[1,2,3] );                // 1 2 3</code></pre>
<p>syntactic replacement for the <code>apply(..)</code></p>
<pre><code class="lang-js">foo.apply( null, [1,2,3] );        // 1 2 3</code></pre>
</section><section><h3 id="spread-out-expand">Spread Out/Expand</h3>
<pre><code class="lang-js">var a = [2,3,4];
var b = [ 1, ...a, 5 ];

console.log( b );                    // [1,2,3,4,5]</code></pre>
</section><section><h3 id="gather">Gather</h3>
<pre><code class="lang-js">function foo(x, y, ...z) {
    console.log( x, y, z );
}

foo( 1, 2, 3, 4, 5 );            // 1 2 [3,4,5]</code></pre>
<pre><code class="lang-js">function foo(...args) {
    console.log( args );
}

foo( 1, 2, 3, 4, 5);            // [1,2,3,4,5]</code></pre>
</section><section><h3 id="solid-alternative-for-arguments-">Solid alternative for <code>arguments</code></h3>
<pre><code class="lang-js">// doing things the new ES6 way
function foo(...args) {
    // `args` is already a real array
    // discard first element in `args`
    args.shift();
    // pass along all of `args` as arguments
    // to `console.log(..)`
    console.log( ...args );
}
// doing things the old-school pre-ES6 way
function bar() {
    // turn `arguments` into a real array
    var args = Array.prototype.slice.call( arguments );
    // add some elements on the end
    args.push( 4, 5 );
    // filter out odd numbers
    args = args.filter( function(v){
        return v % 2 == 0;
    } );
    // pass along all of `args` as arguments
    // to `foo(..)`
    foo.apply( null, args );
}
bar( 0, 1, 2, 3 );                    // 2 4</code></pre>
</section><section><h2 id="default-parameter-values">Default Parameter Values</h2>
<pre><code class="lang-js">function foo(x,y) {
    x = x || 11;
    y = y || 31;

    console.log( x + y );
}

foo();                // 42
foo( 5, 6 );        // 11
foo( 5 );            // 36
foo( null, 6 );        // 17</code></pre>
<pre><code class="lang-js">foo( 0, 42 );        // 53 &lt;-- Oops, not 42</code></pre>
</section><section><h3 id="more-strict">More Strict</h3>
<pre><code class="lang-js">function foo(x,y) {
    x = (x !== undefined) ? x : 11;
    y = (y !== undefined) ? y : 31;

    console.log( x + y );
}

foo( 0, 42 );            // 42
foo( undefined, 6 );    // 17</code></pre>
</section><section><h3 id="es6-default-parameters">ES6 Default Parameters</h3>
<pre><code class="lang-js">function foo(x = 11, y = 31) {
    console.log( x + y );
}

foo();                    // 42
foo( 5, 6 );            // 11
foo( 0, 42 );            // 42

foo( 5 );                // 36
foo( 5, undefined );    // 36 &lt;-- `undefined` is missing
foo( 5, null );            // 5  &lt;-- null coerces to `0`

foo( undefined, 6 );    // 17 &lt;-- `undefined` is missing
foo( null, 6 );            // 6  &lt;-- null coerces to `0`</code></pre>
</section><section><h3 id="default-value-expressions">Default Value Expressions</h3>
<pre><code class="lang-js">function bar(val) {
    console.log( &quot;bar called!&quot; );
    return y + val;
}

function foo(x = y + 3, z = bar( x )) {
    console.log( x, z );
}

var y = 5;
foo();                                // &quot;bar called&quot;
                                    // 8 13
foo( 10 );                            // &quot;bar called&quot;
                                    // 10 15
y = 6;
foo( undefined, 10 );                // 9 10</code></pre>
</section><section><h3 id="-as-a-scope">(..) as a scope</h3>
<pre><code class="lang-js">var w = 1, z = 2;

function foo( x = w + 1, y = x + 1, z = z + 1 ) {
    console.log( x, y, z );
}

foo();                    // ReferenceError</code></pre>
</section><section><h3 id="even-iife">Even IIFE</h3>
<pre><code class="lang-js">function foo( x =
    (function(v){ return v + 11; })( 31 )
) {
    console.log( x );
}

foo();            // 42</code></pre>
<pre><code class="lang-js">function ajax(url, cb = function(){}) {
    // ..
}

ajax( &quot;http://some.url.1&quot; );</code></pre>
</section><section><h2 id="destructuring">Destructuring</h2>
<p>Pre-ES6</p>
<pre><code class="lang-js">function foo() {
    return [1,2,3];
}

var tmp = foo(),
    a = tmp[0], b = tmp[1], c = tmp[2];

console.log( a, b, c );                // 1 2 3</code></pre>
<pre><code class="lang-js">function bar() {
    return {
        x: 4,
        y: 5,
        z: 6
    };
}

var tmp = bar(),
    x = tmp.x, y = tmp.y, z = tmp.z;

console.log( x, y, z );                // 4 5 6</code></pre>
</section><section><h3 id="destructuring-in-action">Destructuring in Action</h3>
<pre><code class="lang-js">var [ a, b, c ] = foo();
var { x: x, y: y, z: z } = bar();

console.log( a, b, c );                // 1 2 3
console.log( x, y, z );                // 4 5 6</code></pre>
<ul>
<li>righthand side of an <code>=</code> assignment, as the value being assigned</li>
<li>lefthand side of the <code>=</code> assignment is treated as a kind of &quot;pattern&quot; for decomposing </li>
</ul>
</section><section><h2 id="object-literal-extensions">Object Literal Extensions</h2>
<pre><code class="lang-js">var { x, y, z } = bar();

console.log( x, y, z );                // 4 5 6</code></pre>
</section><section><h3 id="assign-properties">Assign Properties</h3>
<pre><code class="lang-js">var { x: bam, y: baz, z: bap } = bar();

console.log( bam, baz, bap );        // 4 5 6
console.log( x, y, z );                // ReferenceError</code></pre>
</section><section><h3 id="inverting-target-source-">Inverting <code>target:source</code></h3>
<pre><code class="lang-js">var aa = 10, bb = 20;

var o = { x: aa, y: bb };
var     { x: AA, y: BB } = o;

console.log( AA, BB );                // 10 20</code></pre>
</section><section><h3 id="not-just-declarations">Not Just Declarations</h3>
<pre><code class="lang-js">var a, b, c, x, y, z;  // could be defined

[a,b,c] = foo();
( { x, y, z } = bar() ); // for var/let/const

console.log( a, b, c );                // 1 2 3
console.log( x, y, z );                // 4 5 6</code></pre>
<pre><code class="lang-js">var o = {};

[o.a, o.b, o.c] = foo();
( { x: o.x, y: o.y, z: o.z } = bar() );

console.log( o.a, o.b, o.c );        // 1 2 3
console.log( o.x, o.y, o.z );        // 4 5 6</code></pre>
</section><section><h3 id="with-computed-properties">With Computed Properties</h3>
<pre><code class="lang-js">var which = &quot;x&quot;,
    o = {};

( { [which]: o[which] } = bar() );

console.log( o.x );                    // 4</code></pre>
</section><section><h3 id="declarative-mapping-transformation">Declarative Mapping/Transformation</h3>
<pre><code class="lang-js">var o1 = { a: 1, b: 2, c: 3 },
    o2 = {};

( { a: o2.x, b: o2.y, c: o2.z } = o1 );

console.log( o2.x, o2.y, o2.z );    // 1 2 3</code></pre>
<p>Or the other way around:</p>
<pre><code class="lang-js">var a1 = [ 1, 2, 3 ],
    o2 = {};

[ o2.a, o2.b, o2.c ] = a1;

console.log( o2.a, o2.b, o2.c );    // 1 2 3</code></pre>
</section><section><h3 id="swap-two-variables">Swap Two Variables</h3>
<pre><code class="lang-js">var x = 10, y = 20;

[ y, x ] = [ x, y ];

console.log( x, y );                // 20 10</code></pre>
</section><section><h3 id="repeated-assignments">Repeated Assignments</h3>
<pre><code class="lang-js">var { a: { x: X, x: Y }, a } = { a: { x: 1 } };

X;    // 1
Y;    // 1
a;    // { x: 1 }

( { a: X, a: Y, a: [ Z ] } = { a: [ 1 ] } );

X.push( 2 );
Y[0] = 10;

X;    // [10,2]
Y;    // [10,2]
Z;    // 1</code></pre>
</section><section><h3 id="multiple-lines">Multiple Lines</h3>
<pre><code class="lang-js">// harder to read:
var { a: { b: [ c, d ], e: { f } }, g } = obj;

// better:
var {
    a: {
        b: [ c, d ],
        e: { f }
    },
    g
} = obj;            //declarative readability</code></pre>
</section><section><h3 id="destructuring-assignment-expressions">Destructuring Assignment Expressions</h3>
<pre><code class="lang-js">var o = { a:1, b:2, c:3 },
    a, b, c, p;

p = { a, b, c } = o;

console.log( a, b, c );            // 1 2 3
p === o;                        // true</code></pre>
<p>Chaining </p>
<pre><code class="lang-js">var o = { a:1, b:2, c:3 },
    p = [4,5,6],
    a, b, c, x, y, z;

( {a} = {b,c} = o );
[x,y] = [z] = p;

console.log( a, b, c );            // 1 2 3
console.log( x, y, z );            // 4 5 4</code></pre>
</section><section><h3 id="too-many-too-few-just-enough">Too Many, Too Few, Just Enough</h3>
<pre><code class="lang-js">var [,b] = foo();
var { x, z } = bar();

console.log( b, x, z );                // 2 4 6</code></pre>
<pre><code class="lang-js">var [,,c,d] = foo();
var { w, z } = bar();

console.log( c, z );                // 3 6
console.log( d, w );                // undefined undefined</code></pre>
</section><section><h3 id="gather-rest">Gather/Rest</h3>
<pre><code class="lang-js">var a = [2,3,4];
var b = [ 1, ...a, 5 ];

console.log( b );                    // [1,2,3,4,5]</code></pre>
<pre><code class="lang-js">var a = [2,3,4];
var [ b, ...c ] = a;

console.log( b, c );                // 2 [3,4]</code></pre>
</section><section><h3 id="default-value-assignment">Default Value Assignment</h3>
<pre><code class="lang-js">var [ a = 3, b = 6, c = 9, d = 12 ] = foo();
var { x = 5, y = 10, z = 15, w = 20 } = bar();

console.log( a, b, c, d );            // 1 2 3 12
console.log( x, y, z, w );            // 4 5 6 20</code></pre>
</section><section><h3 id="assignment-expression">Assignment Expression</h3>
<pre><code class="lang-js">var { x, y, z, w: WW = 20 } = bar();

console.log( x, y, z, WW );            // 4 5 6 20</code></pre>
</section><section><h3 id="overuse">Overuse</h3>
<pre><code class="lang-js">var x = 200, y = 300, z = 100;
var o1 = { x: { y: 42 }, z: { y: z } };

( { y: x = { y: y } } = o1 );
( { z: y = { y: z } } = o1 );
( { x: z = { y: x } } = o1 );

console.log( x.y, y.y, z.y );        // 300 100 42</code></pre>
</section><section><h3 id="nested-destructuring">Nested Destructuring</h3>
<pre><code class="lang-js">var a1 = [ 1, [2, 3, 4], 5 ];
var o1 = { x: { y: { z: 6 } } };

var [ a, [ b, c, d ], e ] = a1;
var { x: { y: { z: w } } } = o1;

console.log( a, b, c, d, e );        // 1 2 3 4 5
console.log( w );                    // 6</code></pre>
</section><section><h3 id="flatten-out-object-namespace">Flatten Out Object Namespace</h3>
<pre><code class="lang-js">var App = {
    model: {
        User: function(){ .. }
    }
};

// instead of:
// var User = App.model.User;

var { model: { User } } = App;</code></pre>
</section><section><h3 id="destructuring-parameters">Destructuring Parameters</h3>
<pre><code class="lang-js">function foo( [ x, y ] ) {          // implistic assigment
    console.log( x, y );
}

foo( [ 1, 2 ] );                    // 1 2
foo( [ 1 ] );                        // 1 undefined
foo( [] );                            // undefined undefined</code></pre>
<p>Object destructuring for parameters works, too:</p>
<pre><code class="lang-js">function foo( { x, y } ) {
    console.log( x, y );
}

foo( { y: 1, x: 2 } );                // 2 1
foo( { y: 42 } );                    // undefined 42
foo( {} );                            // undefined undefined</code></pre>
</section><section><h3 id="destructuring-defaults-parameter-defaults">Destructuring Defaults + Parameter Defaults</h3>
<pre><code class="lang-js">function f6({ x = 10 } = {}, { y } = { y: 10 }) {
    console.log( x, y );
}

f6();                                // 10 10
f6( undefined, undefined );            // 10 10
f6( {}, undefined );                // 10 10

f6( {}, {} );                        // 10 undefined
f6( undefined, {} );                // 10 undefined

f6( { x: 2 }, { y: 3 } );            // 2 3</code></pre>
</section><section><h3 id="nested-defaults-destructured-and-restructured">Nested Defaults: Destructured and Restructured</h3>
<pre><code class="lang-js">// taken from: http://es-discourse.com/t/partial-default-arguments/120/7

var defaults = {
    options: {
        remove: true,
        enable: false,
        instance: {}
    },
    log: {
        warn: true,
        error: true
    }
};</code></pre>
<p>with </p>
<pre><code class="lang-js">var config = {
    options: {
        remove: false,
        instance: null
    }
};</code></pre>
</section><section><h3 id="old-school">Old School</h3>
<pre><code class="lang-js">config.options = config.options || {};
config.options.remove = (config.options.remove !== undefined) ?
    config.options.remove : defaults.options.remove;
config.options.enable = (config.options.enable !== undefined) ?
    config.options.enable : defaults.options.enable;
...</code></pre>
</section><section><h3 id="-object-assign-"><code>Object.assign(..)</code></h3>
<p>Only shallow copy</p>
<pre><code class="lang-js">config = Object.assign( {}, defaults, config );</code></pre>
</section><section><h3 id="destructuring-restructuring">Destructuring/Restructuring</h3>
<pre><code class="lang-js">// merge `defaults` into `config`
{
    // destructure (with default value assignments)
    let {
        options: {
            remove = defaults.options.remove,
            enable = defaults.options.enable,
            instance = defaults.options.instance
        } = {},
        log: {
            warn = defaults.log.warn,
            error = defaults.log.error
        } = {}
    } = config;

    // restructure
    config = {
        options: { remove, enable, instance },
        log: { warn, error }
    };
}</code></pre>
</section><section><h3 id="object-literal-extensions">Object Literal Extensions</h3>
<p>ES6 adds a number of important convenience extensions to the humble <code>{ .. }</code> object literal.</p>
</section><section><h3 id="concise-properties">Concise Properties</h3>
<p>Pre-ES6</p>
<pre><code class="lang-js">var x = 2, y = 3,
    o = {
        x: x,
        y: y
    };</code></pre>
<p>ES6</p>
<pre><code class="lang-js">var x = 2, y = 3,
    o = {
        x,
        y
    };</code></pre>
</section><section><h3 id="concise-methods">Concise Methods</h3>
<p>The old way:</p>
<pre><code class="lang-js">var o = {
    x: function(){
        // ..
    },
    y: function(){
        // ..
    }
}</code></pre>
<p>And as of ES6:</p>
<pre><code class="lang-js">var o = {
    x() {
        // ..
    },
    y() {
        // ..
    }
}</code></pre>
</section><section><h3 id="concisely-unnamed">Concisely Unnamed</h3>
<pre><code class="lang-js">runSomething( {
    something(x,y) {
        if (x &gt; y) {
            return something( y, x );
        }

        return y - x;
    }
} );</code></pre>
<p>The above ES6 snippet is interpreted as meaning:</p>
<pre><code class="lang-js">runSomething( {
    something: function(x,y){
        if (x &gt; y) {
            return something( y, x );
        }

        return y - x;
    }
} );</code></pre>
</section><section><h3 id="es5-getter-setter">ES5 Getter/Setter</h3>
<p>More usage in ES6</p>
<pre><code class="lang-js">var o = {
    __id: 10,
    get id() { return this.__id++; },
    set id(v) { this.__id = v; }
}

o.id;            // 10
o.id;            // 11
o.id = 20;
o.id;            // 20

// and:
o.__id;            // 21
o.__id;            // 21 -- still!</code></pre>
</section><section><h3 id="computed-property-names">Computed Property Names</h3>
<pre><code class="lang-js">var prefix = &quot;user_&quot;;

var o = {
    baz: function(..){ .. }
};

o[ prefix + &quot;foo&quot; ] = function(..){ .. };
o[ prefix + &quot;bar&quot; ] = function(..){ .. };
..</code></pre>
<p>ES6</p>
<pre><code class="lang-js">var prefix = &quot;user_&quot;;

var o = {
    baz: function(..){ .. },
    [ prefix + &quot;foo&quot; ]: function(..){ .. },
    [ prefix + &quot;bar&quot; ]: function(..){ .. }
    ..
};</code></pre>
</section><section><h3 id="-symbol-as-property-name"><code>Symbol</code> as Property Name</h3>
<pre><code class="lang-js">var o = {
    [Symbol.toStringTag]: &quot;really cool thing&quot;,
    ..
};</code></pre>
</section><section><h3 id="setting-prototype-">Setting <code>[[Prototype]]</code></h3>
<pre><code class="lang-js">var o1 = {
    // ..
};

var o2 = {
    __proto__: o1,
    // ..
};</code></pre>
<p>With utility</p>
<pre><code class="lang-js">var o1 = {
    // ..
};

var o2 = {
    // ..
};

Object.setPrototypeOf( o2, o1 );</code></pre>
</section><section><h3 id="object-super-">Object <code>super</code></h3>
<pre><code class="lang-js">var o1 = {
    foo() {
        console.log( &quot;o1:foo&quot; );
    }
};

var o2 = {
    foo() {
        super.foo();
        console.log( &quot;o2:foo&quot; );
    }
};

Object.setPrototypeOf( o2, o1 );

o2.foo();        // o1:foo
                // o2:foo</code></pre>
<ul>
<li><code>super</code> allowed only in concise methods</li>
</ul>
</section><section><h2 id="template-literals">Template Literals</h2>
<p>It&#39;s not only about templating like (Mustache, Handlebars, etc)</p>
<p>More appropriate name would be <em>interpolated string literals</em></p>
<ul>
<li>&quot;, &#39;, `</li>
</ul>
</section><section><h3 id="template-literals-usage">Template Literals Usage</h3>
<p>Here&#39;s the old pre-ES6 way:</p>
<pre><code class="lang-js">var name = &quot;Kyle&quot;;

var greeting = &quot;Hello &quot; + name + &quot;!&quot;;

console.log( greeting );            // &quot;Hello Kyle!&quot;
console.log( typeof greeting );        // &quot;string&quot;</code></pre>
<p>Now, consider the new ES6 way:</p>
<pre><code class="lang-js">var name = &quot;Kyle&quot;;

var greeting = `Hello ${name}!`;

console.log( greeting );            // &quot;Hello Kyle!&quot;
console.log( typeof greeting );        // &quot;string&quot;</code></pre>
</section><section><h3 id="multiple-lines">Multiple Lines</h3>
<pre><code class="lang-js">var text =
`Now is the time for all good men
to come to the aid of their
country!`;

console.log( text );
// Now is the time for all good men
// to come to the aid of their
// country!</code></pre>
</section><section><h3 id="interpolated-expressions">Interpolated Expressions</h3>
<pre><code class="lang-js">function upper(s) {
    return s.toUpperCase();
}

var who = &quot;reader&quot;;

var text =
`A very ${upper( &quot;warm&quot; )} welcome
to all of you ${upper( `${who}s` )}!`;

console.log( text );
// A very WARM welcome
// to all of you READERS!</code></pre>
<p>Any valid expression is allowed to appear inside <code>${..}</code> in an interpolated string literal</p>
</section><section><h3 id="expression-scope">Expression Scope</h3>
<pre><code class="lang-js">function foo(str) {
    var name = &quot;foo&quot;;
    console.log( str );
}

function bar() {
    var name = &quot;bar&quot;;
    foo( `Hello from ${name}!` );
}

var name = &quot;global&quot;;

bar();                    // &quot;Hello from bar!&quot;</code></pre>
</section><section><h3 id="tagged-template-literals">Tagged Template Literals</h3>
<pre><code class="lang-js">function foo(strings, ...values) {
    console.log( strings );
    console.log( values );
}

var desc = &quot;awesome&quot;;

foo`Everything is ${desc}!`;
// [ &quot;Everything is &quot;, &quot;!&quot;]
// [ &quot;awesome&quot; ]</code></pre>
</section><section><h3 id="tagged-template-literals-use-case">Tagged Template Literals Use Case</h3>
<pre><code class="lang-js">function dollabillsyall(strings, ...values) {
    return strings.reduce( function(s,v,idx){
        if (idx &gt; 0) {
            if (typeof values[idx-1] == &quot;number&quot;) {
                // look, also using interpolated
                // string literals!
                s += `$${values[idx-1].toFixed( 2 )}`;
            }
            else {
                s += values[idx-1];
            }
        }
        return s + v;
    }, &quot;&quot; );
}
var amt1 = 11.99,
    amt2 = amt1 * 1.08,
    name = &quot;Kyle&quot;;
var text = dollabillsyall
`Thanks for your purchase, ${name}! Your
product cost was ${amt1}, which with tax
comes out to ${amt2}.`

console.log( text );
// Thanks for your purchase, Kyle! Your
// product cost was $11.99, which with tax
// comes out to $12.95.</code></pre>
</section><section><h2 id="arrow-functions">Arrow Functions</h2>
<pre><code class="lang-js">function foo(x,y) {
    return x + y;
}

// versus

var foo = (x,y) =&gt; x + y;</code></pre>
<pre><code class="lang-js">var a = [1,2,3,4,5];

a = a.map( v =&gt; v * 2 );

console.log( a );                // [2,4,6,8,10]</code></pre>
</section><section><h3 id="not-just-shorter-syntax-but-this-">Not Just Shorter Syntax, But <code>this</code></h3>
<pre><code class="lang-js">var controller = {
    makeRequest: (..) =&gt; {
        // ..
        this.helper(..);
    },
    helper: (..) =&gt; {
        // ..
    }
};

controller.makeRequest(..);</code></pre>
</section><section><h3 id="set-of-rules-for-when-">Set of rules for when <code>=&gt;</code></h3>
<ol>
<li>Single-statement inline function expression</li>
<li>No any <code>this</code> issues</li>
<li>No self-referencing (recursion)</li>
</ol>
<p>For learn more, take at look <a href="img/fig1.png">here</a></p>
</section><section><h2 id="-for-of-loops"><code>for..of</code> Loops</h2>
<p>The value you loop over with <code>for..of</code> must be an <em>iterable</em></p>
</section><section><h3 id="pre-es6-version-of-the-for-of-">Pre-ES6 version of the <code>for..of</code></h3>
<pre><code class="lang-js">var a = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;],
    k = Object.keys( a );

for (var val, i = 0; i &lt; k.length; i++) {
    val = a[ k[i] ];
    console.log( val );
}
// &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot;</code></pre>
</section><section><h3 id="es6-but-non-for-of-equivalent">ES6 but non-<code>for..of</code> equivalent</h3>
<pre><code class="lang-js">var a = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;];

for (var val, ret, it = a[Symbol.iterator]();
    (ret = it.next()) &amp;&amp; !ret.done;
) {
    val = ret.value;
    console.log( val );
}
// &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot;</code></pre>
</section><section><h3 id="default-iterables">Default Iterables</h3>
<ul>
<li>Arrays</li>
<li>Strings</li>
<li>Generators</li>
<li>Collections / TypedArrays </li>
</ul>
</section><section><h2 id="-for-of-loops-usage"><code>for..of</code> Loops Usage</h2>
<pre><code class="lang-js">for (var c of &quot;hello&quot;) {
    console.log( c );
}
// &quot;h&quot; &quot;e&quot; &quot;l&quot; &quot;l&quot; &quot;o&quot;</code></pre>
<pre><code class="lang-js">var o = {};

for (o.a of [1,2,3]) {
    console.log( o.a );
}
// 1 2 3

for ({x: o.a} of [ {x: 1}, {x: 2}, {x: 3} ]) {
  console.log( o.a );
}
// 1 2 3</code></pre>
</section><section><h2 id="regular-expressions">Regular Expressions</h2>
<p>Couple of new tricks in ES6</p>
</section><section><h3 id="unicode-flag">Unicode Flag</h3>
<pre><code class="lang-js">/ùÑû/.test( &quot;ùÑû-clef&quot; );            // true</code></pre>
<pre><code class="lang-js">/^.-clef/ .test( &quot;ùÑû-clef&quot; );        // false
/^.-clef/u.test( &quot;ùÑû-clef&quot; );        // true</code></pre>
</section><section><h3 id="sticky-flag">Sticky Flag</h3>
<pre><code class="lang-js">var re1 = /foo/,
    str = &quot;++foo++&quot;;

re1.lastIndex;            // 0
re1.test( str );        // true
re1.lastIndex;            // 0 -- not updated

re1.lastIndex = 4;
re1.test( str );        // true -- ignored `lastIndex`
re1.lastIndex;            // 4 -- not updated</code></pre>
</section><section><h3 id="sticky-positioning">Sticky Positioning</h3>
<pre><code class="lang-js">var re = /\d+\.\s(.*?)(?:\s|$)/y
    str = &quot;1. foo 2. bar 3. baz&quot;;

str.match( re );        // [ &quot;1. foo &quot;, &quot;foo&quot; ]

re.lastIndex;            // 7 -- correct position!
str.match( re );        // [ &quot;2. bar &quot;, &quot;bar&quot; ]

re.lastIndex;            // 14 -- correct position!
str.match( re );        // [&quot;3. baz&quot;, &quot;baz&quot;]</code></pre>
</section><section><h2 id="number-literal-extensions">Number Literal Extensions</h2>
<pre><code class="lang-js">var dec = 42,
    oct = 052,
    hex = 0x2a;</code></pre>
<pre><code class="lang-js">Number( &quot;42&quot; );                // 42
Number( &quot;052&quot; );            // 52
Number( &quot;0x2a&quot; );            // 42</code></pre>
<pre><code class="lang-js">Number( &quot;42&quot; );            // 42
Number( &quot;0o52&quot; );        // 42
Number( &quot;0x2a&quot; );        // 42
Number( &quot;0b101010&quot; );    // 42</code></pre>
</section><section><h2 id="symbols">Symbols</h2>
<pre><code class="lang-js">var sym = Symbol( &quot;some optional description&quot; );

typeof sym;        // &quot;symbol&quot;

sym.toString();        // &quot;Symbol(some optional description)&quot;</code></pre>
</section><section><h3 id="uniq-names">Uniq names</h3>
<pre><code class="lang-js">const EVT_LOGIN = Symbol( &quot;event.login&quot; );

evthub.listen( EVT_LOGIN, function(data){
    // ..
} );</code></pre>
</section><section><h3 id="aka-singleton">Aka Singleton</h3>
<pre><code class="lang-js">const INSTANCE = Symbol( &quot;instance&quot; );

function HappyFace() {
    if (HappyFace[INSTANCE]) return HappyFace[INSTANCE];

    function smile() { .. }

    return HappyFace[INSTANCE] = {
        smile: smile
    };
}

var me = HappyFace(),
    you = HappyFace();

me === you;            // true</code></pre>
</section><section><h3 id="symbol-registry">Symbol Registry</h3>
<pre><code class="lang-js">const EVT_LOGIN = Symbol.for( &quot;event.login&quot; );

console.log( EVT_LOGIN );        // Symbol(event.login)</code></pre>
<p>And:</p>
<pre><code class="lang-js">function HappyFace() {
    const INSTANCE = Symbol.for( &quot;instance&quot; );

    if (HappyFace[INSTANCE]) return HappyFace[INSTANCE];

    // ..

    return HappyFace[INSTANCE] = { .. };
}</code></pre>
</section><section><h3 id="symbols-as-object-properties">Symbols as Object Properties</h3>
<pre><code class="lang-js">var o = {
    foo: 42,
    [ Symbol( &quot;bar&quot; ) ]: &quot;hello world&quot;,
    baz: true
};

Object.getOwnPropertyNames( o );    // [ &quot;foo&quot;,&quot;baz&quot; ]</code></pre>
<p>To retrieve an object&#39;s symbol properties:</p>
<pre><code class="lang-js">Object.getOwnPropertySymbols( o );    // [ Symbol(bar) ]</code></pre>
</section><section><h3 id="built-in-symbols">Built-In Symbols</h3>
<pre><code class="lang-js">var a = [1,2,3];

a[Symbol.iterator];            // native function</code></pre>
<ul>
<li><code>@@iterator</code>, <code>@@toStringTag</code>, <code>@@toPrimitive</code></li>
<li>not in a Symbol register</li>
</ul>
</section><section><h2 id="review">Review</h2>
<ol>
<li>Syntactic sugar for common programming idioms<ul>
<li>default values</li>
<li>spread/gather </li>
<li>destructuring</li>
<li>concise methods/properties</li>
<li>templating literals</li>
</ul>
</li>
<li><code>=&gt;</code> is a nice-syntax, but have issues, like <ul>
<li>non-consistent <code>this</code> behaviour</li>
<li>not for long functions</li>
</ul>
</li>
<li>Expanded Unicode support</li>
<li>Extensions for RegExp</li>
<li>New type for meta-programming - <code>Symbol</code></li>
</ol>
</section><section><h2 id="organization">Organization</h2>
<ul>
<li>Iterators</li>
<li>Generators</li>
<li>Modules</li>
<li>Classes</li>
</ul>
</section><section><h2 id="iterators">Iterators</h2>
<p>An <em>iterator</em> is a structured pattern for pulling information from a source in one-at-a-time fashion</p>
</section><section><h3 id="iterators-specification-interfaces">Iterators Specification Interfaces</h3>
<pre><code>Iterator [required]
    next() {method}: retrieves next IteratorResult</code></pre>
<pre><code>Iterator [optional]
    return() {method}: stops iterator and returns IteratorResult
    throw() {method}: signals error and returns IteratorResult</code></pre>
<pre><code>IteratorResult
    value {property}: current iteration value or final return value
        (optional if `undefined`)
    done {property}: boolean, indicates completion status</code></pre>
<pre><code>Iterable
    @@iterator() {method}: produces an Iterator</code></pre>
<h4 id="iteratorresult">IteratorResult</h4>
<pre><code class="lang-js">{ value: .. , done: true / false }</code></pre>
<p><code>@@iterator</code> is the special built-in <code>symbol</code> </p>
</section><section><h3 id="-next-iteration"><code>next()</code> Iteration</h3>
<pre><code class="lang-js">var arr = [1,2,3];

var it = arr[Symbol.iterator]();

it.next();        // { value: 1, done: false }
it.next();        // { value: 2, done: false }
it.next();        // { value: 3, done: false }

it.next();        // { value: undefined, done: true }</code></pre>
<p><code>done: true</code> when you receive the <code>3</code> value. You have to call <code>next()</code> again</p>
</section><section><h3 id="primitives-iterables-by-default">Primitives Iterables By Default</h3>
<pre><code class="lang-js">var greeting = &quot;hello world&quot;;

var it = greeting[Symbol.iterator]();

it.next();        // { value: &quot;h&quot;, done: false }
it.next();        // { value: &quot;e&quot;, done: false }
..</code></pre>
</section><section><h3 id="collection-iterables-by-default">Collection Iterables by Default</h3>
<pre><code class="lang-js">var m = new Map();
m.set( &quot;foo&quot;, 42 );
m.set( { cool: true }, &quot;hello world&quot; );

var it1 = m[Symbol.iterator]();
var it2 = m.entries();

it1.next();        // { value: [ &quot;foo&quot;, 42 ], done: false }
it2.next();        // { value: [ &quot;foo&quot;, 42 ], done: false }
..</code></pre>
</section><section><h3 id="optional-return-and-throw-">Optional: <code>return(..)</code> and <code>throw(..)</code></h3>
<ul>
<li><code>return(..)</code> is defined as sending a signal to an iterator that the consuming code is complete</li>
<li><code>throw(..)</code> is used to signal an exception/error to an iterator</li>
</ul>
<p><code>return(..)</code>  -  imply stop, however <code>throw(..)</code> doesn&#39;t necessary stop iterator </p>
</section><section><h3 id="iterator-loop">Iterator Loop</h3>
<pre><code class="lang-js">var it = {
    // make the `it` iterator an iterable
    [Symbol.iterator]() { return this; },

    next() { .. },
    ..
};

it[Symbol.iterator]() === it;        // true

for (var v of it) {
    console.log( v );
}</code></pre>
</section><section><h3 id="iterator-loop-with-old-school-loop">Iterator Loop with Old School Loop</h3>
<pre><code class="lang-js">for (var v, res; (res = it.next()) &amp;&amp; !res.done; ) {
    v = res.value;
    console.log( v );
}</code></pre>
</section><section><h3 id="custom-iterators-fibonacci">Custom Iterators - Fibonacci</h3>
<pre><code class="lang-js">var Fib = {
    [Symbol.iterator]() {
        var n1 = 1, n2 = 1;

        return {
            // make the iterator an iterable
            [Symbol.iterator]() { return this; },

            next() {
                var current = n2;
                n2 = n1;
                n1 = n1 + current;
                return { value: current, done: false };
            },

            return(v) {
                console.log(
                    &quot;Fibonacci sequence abandoned.&quot;
                );
                return { value: v, done: true };
            }
        };
    }
};

for (var v of Fib) {
    console.log( v );

    if (v &gt; 50) break;
}
// 1 1 2 3 5 8 13 21 34 55
// Fibonacci sequence abandoned.</code></pre>
</section><section><h3 id="custom-iterators-actions">Custom Iterators - Actions</h3>
<pre><code class="lang-js">var tasks = {
    [Symbol.iterator]() {
        var steps = this.actions.slice();

        return {
            // make the iterator an iterable
            [Symbol.iterator]() { return this; },

            next(...args) {
                if (steps.length &gt; 0) {
                    let res = steps.shift()( ...args );
                    return { value: res, done: false };
                }
                else {
                    return { done: true }
                }
            },

            return(v) {
                steps.length = 0;
                return { value: v, done: true };
            }
        };
    },
    actions: []
};</code></pre>
</section><section><h3 id="custom-iterators-actions">Custom Iterators - Actions</h3>
<pre><code class="lang-js">tasks.actions.push(
    function step1(x){
        console.log( &quot;step 1:&quot;, x );
        return x * 2;
    },
    function step2(x,y){
        console.log( &quot;step 2:&quot;, x, y );
        return x + (y * 2);
    },
    function step3(x,y,z){
        console.log( &quot;step 3:&quot;, x, y, z );
        return (x * y) + z;
    }
);

var it = tasks[Symbol.iterator]();

it.next( 10 );            // step 1: 10
                        // { value:   20, done: false }

it.next( 20, 50 );        // step 2: 20 50
                        // { value:  120, done: false }

it.next( 20, 50, 120 );    // step 3: 20 50 120
                        // { value: 1120, done: false }

it.next();                // { done: true }</code></pre>
</section><section><h3 id="custom-iterator-range">Custom Iterator - Range</h3>
<p>Customization of <code>Number.prototype</code> can give next trick</p>
<pre><code class="lang-js">for (var i of 3) {
    console.log( i );
}
// 0 1 2 3

[...-3];                // [0,-1,-2,-3]</code></pre>
</section><section><h3 id="iterator-consumption">Iterator Consumption</h3>
<pre><code class="lang-js">var a = [1,2,3,4,5];    //any iterable here

function foo(x,y,z,w,p) {
    console.log( x + y + z + w + p );
}
foo( ...a );            // 15

var b = [ 0, ...a, 6 ];
b;                        // [0,1,2,3,4,5,6]

var it = a[Symbol.iterator]();

var [x,y] = it;            // take just the first two elements from `it`
var [z, ...w] = it;        // take the third, then the rest all at once

// is `it` fully exhausted? Yep.
it.next();                // { value: undefined, done: true }

x;                        // 1
y;                        // 2
z;                        // 3
w;                        // [4,5]</code></pre>
</section><section><h2 id="generators">Generators</h2>
<p>It can pause itseld in mid-execution, and can be resumed right away or at later time</p>
</section><section><h3 id="syntax">Syntax</h3>
<pre><code class="lang-js">function *foo() {
    // ..
}</code></pre>
<p>All valid</p>
<pre><code class="lang-js">function *foo()  { .. }
function* foo()  { .. }
function * foo() { .. }
function*foo()   { .. }
..</code></pre>
<p>Concise Method</p>
<pre><code class="lang-js">var a = {
    *foo() { .. }
};</code></pre>
</section><section><h3 id="executing-a-generator">Executing a Generator</h3>
<pre><code class="lang-js">foo();</code></pre>
<p>You can still pass it arguments, as in:</p>
<pre><code class="lang-js">function *foo(x,y) {
    // ..
}

foo( 5, 10 );</code></pre>
</section><section><h3 id="iterator-as-result">Iterator as Result</h3>
<pre><code class="lang-js">function *foo() {
    // ..
}

var it = foo();

// to start/advanced `*foo()`, call
// `it.next(..)`</code></pre>
<h4 id="-yield-"><code>yield</code></h4>
<pre><code class="lang-js">function *foo() {
    var x = 10;
    var y = 20;

    yield;

    var z = x + y;
}</code></pre>
<p><code>yield</code> is not just a pause point. It&#39;s an expression </p>
<pre><code class="lang-js">function *foo() {
    while (true) {
        yield Math.random();
    }
}</code></pre>
</section><section><h3 id="-yield-can-appear-anywhere-a-normal-expression-can"><code>yield</code> can appear anywhere a normal expression can</h3>
<pre><code class="lang-js">function *foo() {
    var arr = [ yield 1, yield 2, yield 3 ];
    console.log( arr, yield 4 );
}</code></pre>
<p>Precedence</p>
<pre><code class="lang-js">var a, b;

a = 3;                    // valid
b = 2 + a = 3;            // invalid
b = 2 + (a = 3);        // valid

yield 3;                // valid
a = 2 + yield 3;        // invalid
a = 2 + (yield 3);        // valid</code></pre>
</section><section><h3 id="-yield-"><code>yield *</code></h3>
<ul>
<li><code>yield * ..</code> requires an iterable</li>
<li>delegates its own host generator&#39;s control to that iterator </li>
</ul>
<pre><code class="lang-js">function *foo() {
    yield *[1,2,3];
}</code></pre>
<pre><code class="lang-js">function *foo() {
    yield 1;
    yield 2;
    yield 3;
}

function *bar() {
    yield *foo();
}</code></pre>
</section><section><h3 id="generator-recursion">Generator Recursion</h3>
<pre><code class="lang-js">function *foo(x) {
    if (x &lt; 3) {
        x = yield *foo( x + 1 );
    }
    return x * 2;
}

foo( 1 );</code></pre>
</section><section><h3 id="iterator-control">Iterator Control</h3>
<pre><code class="lang-js">function *foo() {
    yield 1;
    yield 2;
    yield 3;
}

var it = foo();

it.next();                // { value: 1, done: false }
it.next();                // { value: 2, done: false }
it.next();                // { value: 3, done: false }

it.next();                // { value: undefined, done: true }</code></pre>
</section><section><h3 id="progressive-code-execution">Progressive Code Execution</h3>
<pre><code class="lang-js">function *foo() {
    var x = yield 1;
    var y = yield 2;
    var z = yield 3;
    console.log( x, y, z );
}</code></pre>
<pre><code class="lang-js">var it = foo();

// start up the generator
it.next();                // { value: 1, done: false }

// answer first question
it.next( &quot;foo&quot; );        // { value: 2, done: false }

// answer second question
it.next( &quot;bar&quot; );        // { value: 3, done: false }

// answer third question
it.next( &quot;baz&quot; );        // &quot;foo&quot; &quot;bar&quot; &quot;baz&quot;
                        // { value: undefined, done: true }</code></pre>
</section><section><h3 id="early-completion">Early Completion</h3>
<pre><code class="lang-js">function *foo() {
    yield 1;
    yield 2;
    yield 3;
}

var it = foo();

it.next();                // { value: 1, done: false }

it.return( 42 );        // { value: 42, done: true }

it.next();                // { value: undefined, done: true }</code></pre>
<p><code>return(..)</code> called automatically at the end of iteration</p>
</section><section><h3 id="clean-up-tasks">Clean Up Tasks</h3>
<pre><code class="lang-js">function *foo() {
    try {
        yield 1;
        yield 2;
        yield 3;
    }
    finally {
        console.log( &quot;cleanup!&quot; );
    }
}

for (var v of foo()) {
    console.log( v );
}
// 1 2 3
// cleanup!

var it = foo();

it.next();                // { value: 1, done: false }
it.return( 42 );        // cleanup!
                        // { value: 42, done: true }</code></pre>
<p><strong>Warning:</strong> Do not put a <code>yield</code> statement inside the <code>finally</code> clause!</p>
</section><section><h3 id="early-abort">Early Abort</h3>
<pre><code class="lang-js">function *foo() {
    yield 1;
    yield 2;
    yield 3;
}

var it = foo();

it.next();                // { value: 1, done: false }

try {
    it.throw( &quot;Oops!&quot; );
}
catch (err) {
    console.log( err );    // Exception: Oops!
}

it.next();                // { value: undefined, done: true }</code></pre>
</section><section><h3 id="error-handling">Error Handling</h3>
<pre><code class="lang-js">function *foo() {
    try {
        yield 1;
    }
    catch (err) {
        console.log( err );
    }

    yield 2;

    throw &quot;Hello!&quot;;
}

var it = foo();

it.next();                // { value: 1, done: false }

try {
    it.throw( &quot;Hi!&quot; );    // Hi!
                        // { value: 2, done: false }
    it.next();

    console.log( &quot;never gets here&quot; );
}
catch (err) {
    console.log( err );    // Hello!
}</code></pre>
</section><section><h3 id="error-propagation-in-both-directions">Error Propagation in Both Directions</h3>
<pre><code class="lang-js">function *foo() {
    try {
        yield 1;
    }
    catch (err) {
        console.log( err );
    }

    yield 2;

    throw &quot;foo: e2&quot;;
}

function *bar() {
    try {
        yield *foo();

        console.log( &quot;never gets here&quot; );
    }
    catch (err) {
        console.log( err );
    }
}

var it = bar();

try {
    it.next();            // { value: 1, done: false }

    it.throw( &quot;e1&quot; );    // e1
                        // { value: 2, done: false }

    it.next();            // foo: e2
                        // { value: undefined, done: true }
}
catch (err) {
    console.log( &quot;never gets here&quot; );
}

it.next();                // { value: undefined, done: true }</code></pre>
<p>The error doesn&#39;t pass through <code>*bar()</code> like the <code>1</code> value did.</p>
</section><section><h3 id="transpiling-a-generator">Transpiling a Generator</h3>
<p>For example Facebook&#39;s Regenerator tool (<a href="https://facebook.github.io/regenerator/">https://facebook.github.io/regenerator/</a>).</p>
</section><section><h3 id="generator-uses">Generator Uses</h3>
<ul>
<li><em>Producing a series of values</em></li>
<li><em>Queue of tasks to perform serially</em></li>
</ul>
</section><section><h2 id="modules">Modules</h2>
<p>Most important code organization pattern in all of JavaScript</p>
</section><section><h3 id="the-old-way">The Old Way</h3>
<p>The traditional module pattern is based on an outer function with inner variables and functions, and a returned &quot;public API&quot; with methods that have closure over the inner data and capabilities. It&#39;s often expressed like this:</p>
<pre><code class="lang-js">var me = (function Hello(name){
    function greeting() {
        console.log( &quot;Hello &quot; + name + &quot;!&quot; );
    }

    // public API
    return {
        greeting: greeting
    };
})( &quot;Kyle&quot; );

me.greeting();            // Hello Kyle!</code></pre>
</section><section><h3 id="moving-forward">Moving Forward</h3>
<ul>
<li>ES6 uses file-based modules, meaning one module per file</li>
<li>The API of an ES6 module is static</li>
<li>ES6 modules are singletons</li>
<li>The properties and methods of module are bindings</li>
<li>Importing a module is the same thing as statically requesting it to load </li>
</ul>
<h4 id="commonjs-amd-umd">CommonJS, AMD/UMD</h4>
<p>Transpilers will be an absolute necessity in the way to ES6 modules</p>
</section><section><h3 id="the-new-way">The New Way</h3>
<p>The two main new keywords that enable ES6 modules are <code>import</code> and <code>export</code>.</p>
<h4 id="-export-ing-api-members"><code>export</code>ing API Members</h4>
<pre><code class="lang-js">export function foo() {
    // ..
}

export var awesome = 42;

var bar = [1,2,3];
export { bar };</code></pre>
<p>Another way of expressing the same exports:</p>
<pre><code class="lang-js">function foo() {
    // ..
}

var awesome = 42;
var bar = [1,2,3];

export { foo, awesome, bar };</code></pre>
<p>Rename aka alias</p>
<pre><code class="lang-js">function foo() { .. }

export { foo as bar };</code></pre>
</section><section><h3 id="-default-export">&#39;default&#39; export</h3>
<pre><code class="lang-js">function foo(..) {
    // ..
}

export default foo;</code></pre>
<p>And this one:</p>
<pre><code class="lang-js">function foo(..) {
    // ..
}

export { foo as default };</code></pre>
<pre><code class="lang-js">export default function foo(..) {
    // ..
}</code></pre>
</section><section><h3 id="-import-ing-api-members"><code>import</code>ing API Members</h3>
<pre><code class="lang-js">import { foo, bar, baz } from &quot;foo&quot;;</code></pre>
<ul>
<li>not a destructuring</li>
<li>&quot;foo&quot; - <em>module specifier</em> any string (aka path), ES6 doesn&#39;t care</li>
</ul>
</section><section><h3 id="different-imports">Different imports</h3>
<pre><code class="lang-js">import { foo } from &quot;foo&quot;;

foo();</code></pre>
<pre><code class="lang-js">import { foo as theFooFunc } from &quot;foo&quot;;

theFooFunc();</code></pre>
<pre><code class="lang-js">import foo from &quot;foo&quot;;

// or:
import { default as foo } from &quot;foo&quot;;</code></pre>
</section><section><h3 id="entire-api-to-single-module">Entire API to single module</h3>
<pre><code class="lang-js">import * as foo from &quot;foo&quot;;

foo.bar();
foo.x;            // 42
foo.baz();</code></pre>
<p>or </p>
<pre><code class="lang-js">export default function foo() { .. }
export function bar() { .. }
export function baz() { .. }</code></pre>
<p>And this <code>import</code>:</p>
<pre><code class="lang-js">import foofn, * as hello from &quot;world&quot;;

foofn();
hello.default();
hello.bar();
hello.baz();</code></pre>
</section><section><h3 id="es6-s-module-philosophy">ES6`s module philosophy</h3>
<p>Import only specific bindings which you need</p>
</section><section><h3 id="immutable-read-only-binding">Immutable read-only binding</h3>
<pre><code class="lang-js">import foofn, * as hello from &quot;world&quot;;

foofn = 42;            // (runtime) TypeError!
hello.default = 42;    // (runtime) TypeError!
hello.bar = 42;        // (runtime) TypeError!
hello.baz = 42;        // (runtime) TypeError!</code></pre>
</section><section><h3 id="-import-are-hoisted-"><code>import</code> are &quot;hoisted&quot;</h3>
<pre><code class="lang-js">foo();

import { foo } from &quot;foo&quot;;</code></pre>
</section><section><h3 id="basic-import-">Basic <code>import</code></h3>
<pre><code class="lang-js">import &quot;foo&quot;;</code></pre>
</section><section><h3 id="circular-module-dependency">Circular Module Dependency</h3>
<p>Let&#39;s consider how ES6 handles this. First, module <code>&quot;A&quot;</code>:</p>
<pre><code class="lang-js">import bar from &quot;B&quot;;

export default function foo(x) {
    if (x &gt; 10) return bar( x - 1 );
    return x * 2;
}</code></pre>
<p>Now, module <code>&quot;B&quot;</code>:</p>
<pre><code class="lang-js">import foo from &quot;A&quot;;

export default function bar(y) {
    if (y &gt; 5) return foo( y / 2 );
    return y * 3;
}</code></pre>
</section><section><h3 id="in-a-rough-conceptual-sense">In a rough conceptual sense</h3>
<ol>
<li>Start analyzing &#39;A&#39;, find out A&#39;s API, fetch B </li>
<li>Analyzing B, find out B&#39;s API, finish A, finish B </li>
</ol>
</section><section><h3 id="module-loading">Module Loading</h3>
<ul>
<li>another specification <a href="http://whatwg.github.io/loader/">http://whatwg.github.io/loader/</a></li>
</ul>
</section><section><h2 id="classes">Classes</h2>
<pre><code class="lang-js">class Foo {
    constructor(a,b) {
        this.x = a;
        this.y = b;
    }

    gimmeXY() {
        return this.x * this.y;
    }
}</code></pre>
</section><section><h3 id="old-way">Old Way</h3>
<pre><code class="lang-js">function Foo(a,b) {
    this.x = a;
    this.y = b;
}

Foo.prototype.gimmeXY = function() {
    return this.x * this.y;
}</code></pre>
</section><section><h3 id="usage-pre-es6-and-es6">Usage pre-ES6 and ES6</h3>
<pre><code class="lang-js">var f = new Foo( 5, 15 );

f.x;                        // 5
f.y;                        // 15
f.gimmeXY();                // 75</code></pre>
</section><section><h3 id="-extends-and-super-"><code>extends</code> and <code>super</code></h3>
<pre><code class="lang-js">class Bar extends Foo {
    constructor(a,b,c) {
        super( a, b );
        this.z = c;
    }

    gimmeXYZ() {
        return super.gimmeXY() * this.z;
    }
}

var b = new Bar( 5, 15, 25 );

b.x;                        // 5
b.y;                        // 15
b.z;                        // 25
b.gimmeXYZ();                // 1875</code></pre>
</section><section><h3 id="-extend-ing-natives"><code>extend</code>ing Natives</h3>
<pre><code class="lang-js">class MyCoolArray extends Array {
    first() { return this[0]; }
    last() { return this[this.length - 1]; }
}

var a = new MyCoolArray( 1, 2, 3 );

a.length;                    // 3
a;                            // [1,2,3]

a.first();                    // 1
a.last();                    // 3</code></pre>
</section><section><h3 id="-extend-ing-natives"><code>extend</code>ing Natives</h3>
<pre><code class="lang-js">class Oops extends Error {
    constructor(reason) {
        super(reason);
        this.oops = reason;
    }
}

// later:
var ouch = new Oops( &quot;I messed up!&quot; );
throw ouch;</code></pre>
</section><section><h3 id="-static-"><code>static</code></h3>
<pre><code class="lang-js">class Foo {
    static cool() { console.log( &quot;cool&quot; ); }
    wow() { console.log( &quot;wow&quot; ); }
}

class Bar extends Foo {
    static awesome() {
        super.cool();
        console.log( &quot;awesome&quot; );
    }
    neat() {
        super.wow();
        console.log( &quot;neat&quot; );
    }
}

Foo.cool();                    // &quot;cool&quot;
Bar.cool();                    // &quot;cool&quot;
Bar.awesome();                // &quot;cool&quot;
                            // &quot;awesome&quot;

var b = new Bar();
b.neat();                    // &quot;wow&quot;
                            // &quot;neat&quot;

b.awesome;                    // undefined
b.cool;                        // undefined</code></pre>
</section><section><h2 id="review">Review</h2>
<ul>
<li>ES6 provides several new features for code organization</li>
<li>Iterators provide sequential access to data or operations</li>
<li>Generators are locally pause/resume capable functions controlled by an iterator</li>
<li>Modules allow private encapsulation of implementation details with a publicly exported API</li>
<li>Classes provide cleaner syntax around prototype-based coding</li>
</ul>
</section>
			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,
                slideNumber: true,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

				// Parallax scrolling
				// parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
				// parallaxBackgroundSize: '2100px 900px',

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});

		</script>

	</body>
</html>
