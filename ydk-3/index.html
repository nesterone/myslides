<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>You Don't Know JS - scope & closure</title>

		<meta name="description" content="scope & closure">
		<meta name="author" content="Igor Nesterenko">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.min.css">
		<link rel="stylesheet" href="css/theme/default.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', include the PDF print sheet -->
		<script>
			if( window.location.search.match( /print-pdf/gi ) ) {
				var link = document.createElement( 'link' );
				link.rel = 'stylesheet';
				link.type = 'text/css';
				link.href = 'css/print/pdf.css';
				document.getElementsByTagName( 'head' )[0].appendChild( link );
			}
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->

        <style type="text/css">
            .left-side {
                text-align: left;

            }
        </style>
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
                <section><h3 id="you-don-t-know-js-types-grammar">You Don&#39;t Know JS: Types &amp; Grammar</h3>
<h5 id="types-grammar">types &amp; grammar</h5>
<p>inspired by <a href="https://github.com/getify/You-Dont-Know-JS/tree/master/types%20%26%20grammar">getify</a></p>
</section><section><h3 id="presented-by">Presented by</h3>
<ul>
<li><a href="https://twitter.com/nesterone">Igor Nesterenko</a></li>
</ul>
</section><section><h3 id="high-level-overview">High-level Overview</h3>
<ul>
<li>Types</li>
<li>Values</li>
<li>Natives</li>
<li>Coercion</li>
<li>Grammar</li>
</ul>
</section><section><h2 id="types">Types</h2>
<ul>
<li>What it&#39;s type ? Why does it matter ?</li>
<li>Built-in Types</li>
<li>Values as Types</li>
<li>Review</li>
</ul>
</section><section><h3 id="what-it-s-type-why-does-it-matter-">What it&#39;s type ? Why does it matter ?</h3>
<ul>
<li>These two values have different types.</li>
<li>There are many different ways that coercion can happen</li>
</ul>
</section><section><h3 id="built-in-types">Built-in Types</h3>
<ul>
<li><code>null</code></li>
<li><code>undefined</code></li>
<li><code>boolean</code></li>
<li><code>number</code></li>
<li><code>string</code></li>
<li><code>object</code></li>
<li><code>symbol</code> -- added in ES6!</li>
</ul>
</section><section><h3 id="the-typeof-">The &quot;typeof&quot;</h3>
<pre><code class="lang-js">typeof undefined     === &quot;undefined&quot;; // true
typeof true          === &quot;boolean&quot;;   // true
typeof 42            === &quot;number&quot;;    // true
typeof &quot;42&quot;          === &quot;string&quot;;    // true
typeof { life: 42 }  === &quot;object&quot;;    // true

// added in ES6!
typeof Symbol()      === &quot;symbol&quot;;    // true</code></pre>
</section><section><h3 id="-typeof-bug">&quot;typeof&quot; bug</h3>
<p><code>typeof null === &quot;object&quot;; // true</code></p>
</section><section><h3 id="-subtypes-of-object">&quot;Subtypes&quot; of object</h3>
<pre><code class="lang-js">typeof function a(){ /* .. */ } === &quot;function&quot;; // true, callable object
typeof [1,2,3] === &quot;object&quot;; // true</code></pre>
</section><section><h3 id="values-as-types">Values as Types</h3>
<p>In JavaScript, variables don&#39;t have types -- <strong>values have types</strong></p>
</section><section><h3 id="-undefined-vs-undeclared-"><code>undefined</code> vs &quot;undeclared&quot;</h3>
<p>In JavaScript, they&#39;re quite different</p>
<pre><code class="lang-js">var a;

typeof a; // &quot;undefined&quot;
typeof b; // &quot;undefined&quot;, safety guard

a; // undefined
b; // ReferenceError: b is not defined</code></pre>
</section><section><h3 id="-typeof-undeclared"><code>typeof</code> Undeclared</h3>
<ul>
<li>feature detection </li>
<li>different JS environments</li>
<li>different modes: development, production</li>
</ul>
<pre><code class="lang-js">
// this is a safe existence check
if (typeof DEBUG !== &quot;undefined&quot;) {
    console.log( &quot;Debugging is starting&quot; );
}

// this is a safe existence check
if (typeof someApi !== &quot;undefined&quot;){
    simeApi.runIt();
}</code></pre>
</section><section><h3 id="review">Review</h3>
<ul>
<li>seven build-in types</li>
<li><code>undefined</code> and &quot;undeclared&quot; are different</li>
<li>usage of <code>typeof</code> for safe existence check</li>
</ul>
</section><section><h2 id="values">Values</h2>
<ul>
<li>Arrays</li>
<li>Strings</li>
<li>Numbers</li>
<li>Special Values</li>
<li>Values vs. Reference</li>
<li>Review</li>
</ul>
</section><section><h2 id="arrays">Arrays</h2>
<ul>
<li>Arrays</li>
<li>Array-Likes</li>
</ul>
</section><section><h3 id="arrays">Arrays</h3>
<pre><code class="lang-js">
var a = [ 1, &quot;2&quot;, [3] ];

a.length;        // 3
a[0] === 1;        // true
a[2][0] === 3;    // true

a.length;    // 0

a[0] = 1;
a[1] = &quot;2&quot;;
a[2] = [ 3 ];

a.length;    // 3</code></pre>
</section><section><h3 id="-sparse-arrays">&quot;Sparse&quot; Arrays</h3>
<pre><code class="lang-js">var a = [ ];

a[0] = 1;
// no `a[1]` slot set here
a[2] = [ 3 ];

a[1];        // undefined

a.length;    // 3</code></pre>
</section><section><h3 id="string-ad-index">String ad Index</h3>
<pre><code class="lang-js">var a = [ ];

a[&quot;13&quot;] = 42; // coersion from string to number

a.length; // 14</code></pre>
<p>use number for index</p>
</section><section><h3 id="array-likes">Array-Likes</h3>
<ul>
<li>&#39;arguments&#39; in function</li>
<li>some of DOM elements (NodesList)</li>
</ul>
<pre><code class="lang-js">function foo() {
    var arr = Array.prototype.slice.call( arguments );
    arr.push( &quot;bam&quot; );
    console.log( arr );
}

foo( &quot;bar&quot;, &quot;baz&quot; ); // [&quot;bar&quot;,&quot;baz&quot;,&quot;bam&quot;]

// in ES6

var arr = Array.from( arguments );</code></pre>
</section><section><h3 id="string">String</h3>
<ul>
<li>Arrays and Strings Similarities</li>
<li>Arrays and String Differences</li>
<li>Reuse of Methods from Arrays</li>
</ul>
</section><section><h3 id="arrays-and-strings-similarities">Arrays and Strings Similarities</h3>
<pre><code class="lang-js">var a = &quot;foo&quot;;
var b = [&quot;f&quot;,&quot;o&quot;,&quot;o&quot;];

a.length;                            // 3
b.length;                            // 3

a.indexOf( &quot;o&quot; );                    // 1
b.indexOf( &quot;o&quot; );                    // 1

var c = a.concat( &quot;bar&quot; );            // &quot;foobar&quot;
var d = b.concat( [&quot;b&quot;,&quot;a&quot;,&quot;r&quot;] );    // [&quot;f&quot;,&quot;o&quot;,&quot;o&quot;,&quot;b&quot;,&quot;a&quot;,&quot;r&quot;]

a === c;                            // false
b === d;                            // false

a;                                    // &quot;foo&quot;
b;                                    // [&quot;f&quot;,&quot;o&quot;,&quot;o&quot;]</code></pre>
</section><section><h3 id="strings-are-immutable">Strings are immutable</h3>
<pre><code class="lang-js">a[1] = &quot;O&quot;;
b[1] = &quot;O&quot;;

a; // &quot;foo&quot;
b; // [&quot;f&quot;,&quot;O&quot;,&quot;o&quot;];

c = a.toUpperCase();
a === c;    // false
a;            // &quot;foo&quot;
c;            // &quot;FOO&quot;

b.push( &quot;!&quot; );
b;            // [&quot;f&quot;,&quot;O&quot;,&quot;o&quot;,&quot;!&quot;]</code></pre>
</section><section><h3 id="reuse-of-methods-from-arrays">Reuse of Methods from Arrays</h3>
<ul>
<li>&quot;borrow&quot; non-mutation array methods </li>
</ul>
<pre><code class="lang-js">a.join;            // undefined
a.map;            // undefined

var c = Array.prototype.join.call( a, &quot;-&quot; );
var d = Array.prototype.map.call( a, function(v){
    return v.toUpperCase() + &quot;.&quot;;
} ).join( &quot;&quot; );

c;                // &quot;f-o-o&quot;
d;                // &quot;F.O.O.&quot;</code></pre>
</section><section><h2 id="numbers">Numbers</h2>
<ul>
<li>Numeric Syntax</li>
<li>Small Decimal Values</li>
<li>Safe Integer Ranges</li>
<li>Testing for Integers</li>
<li>32-bit (Signed) Integers</li>
</ul>
</section><section><h3 id="numbers">Numbers</h3>
<p>In JS we have only Numbers. &quot;IEEE 754&quot; standard, often called &quot;floating-point.&quot;</p>
</section><section><h3 id="numeric-syntax">Numeric Syntax</h3>
<pre><code class="lang-js">var a = 42;     // base-10 decimal literals
var b = 42.3;
var c1 = 0.3;   
var c2 = .3;    // valid
var d1 = 42.0
var d2 = 42.    // valid</code></pre>
</section><section><h3 id="exponent-form">Exponent Form</h3>
<pre><code class="lang-js">var a = 5E10;
a;                    // 50000000000
a.toExponential();    // &quot;5e+10&quot;

var b = a * a;      // very large numbers
b;                    // 2.5e+21

var c = 1 / a;
c;                    // 2e-11</code></pre>
</section><section><h3 id="fixed-and-precision">Fixed and Precision</h3>
<pre><code class="lang-js">var a = 42.59;

a.toFixed( 0 ); // &quot;43&quot;
a.toFixed( 1 ); // &quot;42.6&quot;
a.toFixed( 2 ); // &quot;42.59&quot;
a.toFixed( 3 ); // &quot;42.590&quot;
a.toFixed( 4 ); // &quot;42.5900&quot;

a.toPrecision( 1 ); // &quot;4e+1&quot;
a.toPrecision( 2 ); // &quot;43&quot;
a.toPrecision( 3 ); // &quot;42.6&quot;
a.toPrecision( 4 ); // &quot;42.59&quot;
a.toPrecision( 5 ); // &quot;42.590&quot;
a.toPrecision( 6 ); // &quot;42.5900&quot;</code></pre>
</section><section><h3 id="other-bases">Other Bases</h3>
<pre><code class="lang-js">0xf3; // hexadecimal for: 243
0Xf3; // ditto

0363; // octal for: 243, doesn&#39;t allowed in strict mode

//ES 6
0o363;        // octal for: 243
0O363;        // or

0b11110011;    // binary for: 243
0B11110011; // or</code></pre>
</section><section><h3 id="small-decimal-values">Small Decimal Values</h3>
<ul>
<li>all languages based on &quot;IEEE 754&quot;</li>
</ul>
<pre><code class="lang-js">0.1 + 0.2 === 0.3; // false</code></pre>
</section><section><h3 id="compare-small-decimal-values">Compare Small Decimal Values</h3>
<pre><code class="lang-js">if (!Number.EPSILON) {
    //emulate ES6
    Number.EPSILON = Math.pow(2,-52);
}

function numbersCloseEnoughToEqual(n1,n2) {
    return Math.abs( n1 - n2 ) &lt; Number.EPSILON;
}

var a = 0.1 + 0.2;
var b = 0.3;

numbersCloseEnoughToEqual( a, b );                    // true
numbersCloseEnoughToEqual( 0.0000001, 0.0000002 );    // fals</code></pre>
</section><section><h3 id="safe-integer-ranges">Safe Integer Ranges</h3>
<ul>
<li>Number.MAX_VALUE and Number.MIN_VALUE - not quite useful</li>
<li>ES6 Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER</li>
<li>Big numbers may get official support soon</li>
</ul>
</section><section><h3 id="testing-for-integers">Testing for Integers</h3>
<pre><code class="lang-js">if (!Number.isInteger) {
    //emulate ES6
    Number.isInteger = function(num) {
        return typeof num == &quot;number&quot; &amp;&amp; num % 1 == 0;
    };
}

Number.isInteger( 42 );        // true
Number.isInteger( 42.000 );    // true
Number.isInteger( 42.3 );    // false</code></pre>
</section><section><h3 id="32-bit-signed-integers">32-bit (Signed) Integers</h3>
<ul>
<li>64-bit Floating Point</li>
<li>bitwise operation only in 32-bit</li>
</ul>
</section><section><h2 id="special-values">Special Values</h2>
<ul>
<li>The Non-value Values</li>
<li>Undefined</li>
<li>Special Numbers</li>
<li>Special Equality</li>
</ul>
</section><section><h3 id="the-non-value-values">The Non-value Values</h3>
<ul>
<li><code>null</code> is an empty value</li>
<li><code>undefined</code> is a missing value</li>
</ul>
<p>Or:</p>
<ul>
<li><code>undefined</code> hasn&#39;t had a value yet</li>
<li><code>null</code> had a value and doesn&#39;t anymore</li>
</ul>
</section><section><h3 id="undefined">Undefined</h3>
<pre><code class="lang-js">
function foo() {
    undefined = 2; // really bad idea!
}

foo();</code></pre>
</section><section><h3 id="undefined">Undefined</h3>
<pre><code class="lang-js">
function foo() {
    &quot;use strict&quot;;
    undefined = 2; // TypeError!
}

foo();</code></pre>
</section><section><h3 id="undefined">Undefined</h3>
<pre><code class="lang-js">
function foo() {
    &quot;use strict&quot;;
    var undefined = 2;
    console.log( undefined ); // 2
}

foo();</code></pre>
<p><strong>Friends don&#39;t let friends override <code>undefined</code>.</strong> Ever.</p>
</section><section><h3 id="-void-operator"><code>void</code> Operator</h3>
<p>The expression <code>void ___</code> &quot;voids&quot; out any value (undefined)</p>
<pre><code class="lang-js">function doSomething() {
    // note: `APP.ready` is provided by our application
    if (!APP.ready) {
        // try again later
        return void setTimeout( doSomething, 100 );
    }

    var result;

    // do some other stuff
    return result;
}

// were we able to do it right away?
if (doSomething()) {
    // handle next tasks right away
}</code></pre>
</section><section><h3 id="special-numbers">Special Numbers</h3>
<p>The <code>number</code> type includes several special values. We&#39;ll take a look at each in detail.</p>
</section><section><h3 id="the-not-number-number">The Not Number, Number</h3>
<p><code>NaN</code> literally stands for &quot;not a <code>number</code>&quot;</p>
<pre><code class="lang-js">var a = 2 / &quot;foo&quot;;        // NaN

typeof a === &quot;number&quot;;    // true

a == NaN;    // false
a === NaN;    // false</code></pre>
</section><section><h3 id="19-years-isnan-bug">19 years <code>isNaN</code> bug</h3>
<pre><code class="lang-js">var a = 2 / &quot;foo&quot;;
var b = &quot;foo&quot;;

a; // NaN
b; // &quot;foo&quot;

window.isNaN( a ); // true
window.isNaN( b ); // true -- ouch!

if (!Number.isNaN) {
    // emulate ES6
    Number.isNaN = function(n) {
        return (
            typeof n === &quot;number&quot; &amp;&amp;
            window.isNaN( n )
        );
    };
}

var a = 2 / &quot;foo&quot;;
var b = &quot;foo&quot;;

Number.isNaN( a ); // true
Number.isNaN( b ); // false -- phew!</code></pre>
</section><section><h3 id="infinities">Infinities</h3>
<pre><code class="lang-js">var a = 1 / 0;    // Infinity, yep not an error
var b = -1 / 0;    // -Infinity

var a = Number.MAX_VALUE;    // 1.7976931348623157e+308
a + a;                        // Infinity
a + Math.pow( 2, 970 );        // Infinity
a + Math.pow( 2, 969 );        // 1.7976931348623157e+308</code></pre>
</section><section><h3 id="zeros">Zeros</h3>
<pre><code class="lang-js">var a = 0 / -3; // -0
var b = 0 * -3; // -0

var a = 0 / -3;

// (some browser) consoles at least get it right
a;                            // -0

// but the spec insists on lying to you!
a.toString();                // &quot;0&quot;
a + &quot;&quot;;                        // &quot;0&quot;
String( a );                // &quot;0&quot;

// strangely, even JSON gets in on the deception
JSON.stringify( a );        // &quot;0&quot;

-0 == 0;    // true
+0 == 0;   // true
-0 === 0;    // true
+0 === 0;   // true</code></pre>
</section><section><h3 id="distinguish-zeros">Distinguish Zeros</h3>
<pre><code class="lang-js">function isNegZero(n) {
    n = Number( n );
    return (n === 0) &amp;&amp; (1 / n === -Infinity);
}

isNegZero( -0 );        // true
isNegZero( 0 / -3 );    // true
isNegZero( 0 );            // false</code></pre>
</section><section><h3 id="special-equality-for-tricky-cases-">Special Equality (for tricky cases)</h3>
<pre><code class="lang-js">if (!Object.is) {
    // emulate ES6
    Object.is = function(v1, v2) {
        // test for `-0`
        if (v1 === 0 &amp;&amp; v2 === 0) {
            return 1 / v1 === 1 / v2;
        }
        // test for `NaN`
        if (v1 !== v1) {
            return v2 !== v2;
        }
        // everything else
        return v1 === v2;
    };
}

var a = 2 / &quot;foo&quot;;
var b = -3 * 0;

Object.is( a, NaN );    // true
Object.is( b, -0 );        // true

Object.is( b, 0 );        // false</code></pre>
</section><section><h2 id="value-vs-reference">Value vs. Reference</h2>
<p>In JavaScript, there are no pointers</p>
</section><section><h3 id="value-copy">Value Copy</h3>
<pre><code class="lang-js">var a = 2;
var b = a; // `b` is always a copy of the value in `a`
b++;
a; // 2
b; // 3</code></pre>
<p>All simple values: <code>null</code>, <code>undefined</code>, <code>string</code>, <code>number</code>, <code>boolean</code>, and ES6&#39;s <code>symbol</code>.</p>
</section><section><h3 id="reference-copy">Reference Copy</h3>
<pre><code class="lang-js">var c = [1,2,3];
var d = c; // `d` is a reference to the shared `[1,2,3]` value
d.push( 4 );
c; // [1,2,3,4]
d; // [1,2,3,4]</code></pre>
<p>For Objects</p>
</section><section><h3 id="common-confusions-with-function-parameters">Common Confusions With Function Parameters</h3>
<pre><code class="lang-js">function foo(x) {
    x.push( 4 );
    x; // [1,2,3,4]

    // later
    x = [4,5,6];
    x.push( 7 );
    x; // [4,5,6,7]
}

var a = [1,2,3];

foo( a );

a; // [1,2,3,4]  not  [4,5,6,7]</code></pre>
</section><section><h3 id="common-confusions-with-function-parameters">Common Confusions With Function Parameters</h3>
<pre><code class="lang-js">function foo(x) {
    x = x + 1;
    x; // 3
}

var a = 2;
var b = new Number( a ); // or equivalently `Object(a)`

foo( b );
console.log( b ); // 2, not 3</code></pre>
<p>primitive value is <em>not mutable</em>, even boxed (wrapped in an object)</p>
</section><section><h2 id="review">Review</h2>
<ol>
<li><code>array</code>s are simply numerically indexed collections of any value-type</li>
<li>Numbers in JavaScript include both &quot;integers&quot; and floating-point values</li>
<li>The <code>null</code> type has just one value: <code>null</code></li>
<li><code>undefined</code> is basically the default value</li>
<li><code>void</code> operator lets you create the <code>undefined</code> value from any other value</li>
<li><code>number</code>s include several special values, like <code>NaN</code>, <code>+Infinity</code>, <code>-Infinity</code>, <code>-0</code></li>
<li>Simple values assigned/passed by <code>value-copy</code></li>
<li>Compound values assigned/passed by <code>reference-copy</code></li>
</ol>
</section><section><h2 id="natives">Natives</h2>
<ul>
<li>Internal <code>[[Class]]</code></li>
<li>Boxing Wrappers</li>
<li>Unboxing</li>
<li>Natives as Constructors</li>
<li>Review</li>
</ul>
</section><section><h3 id="list-of-natives">List of Natives</h3>
<ul>
<li><code>String()</code></li>
<li><code>Number()</code></li>
<li><code>Boolean()</code></li>
<li><code>Array()</code></li>
<li><code>Object()</code></li>
<li><code>Function()</code></li>
<li><code>RegExp()</code></li>
<li><code>Date()</code></li>
<li><code>Error()</code></li>
<li><code>Symbol()</code> -- added in ES6!</li>
</ul>
</section><section><h3 id="object-wrappers-around-primitives">Object wrappers around primitives</h3>
<pre><code class="lang-js">var a = new String( &quot;abc&quot; );

typeof a; // &quot;object&quot; ... not &quot;String&quot;

a instanceof String; // true

Object.prototype.toString.call( a ); // &quot;[object String]&quot;</code></pre>
</section><section><h3 id="internal-class-">Internal <code>[[Class]]</code></h3>
<p>Internal <em>class</em> classification rather than related to classes from traditional class-oriented coding</p>
<pre><code class="lang-js">Object.prototype.toString.call( [1,2,3] );            // &quot;[object Array]&quot;
Object.prototype.toString.call( /regex-literal/i );    // &quot;[object RegExp]&quot;

Object.prototype.toString.call( null );            // &quot;[object Null]&quot;
Object.prototype.toString.call( undefined );    // &quot;[object Undefined]&quot;

Object.prototype.toString.call( &quot;abc&quot; );    // &quot;[object String]&quot;
Object.prototype.toString.call( 42 );        // &quot;[object Number]&quot;
Object.prototype.toString.call( true );        // &quot;[object Boolean]&quot;</code></pre>
</section><section><h3 id="boxing-wrappers">Boxing Wrappers</h3>
<pre><code class="lang-js">var a = &quot;abc&quot;;

a.length; // 3
a.toUpperCase(); // &quot;ABC&quot;</code></pre>
<p>It&#39;s better to just let the boxing happen implicitly where necessary</p>
</section><section><h3 id="object-wrapper-gotchas">Object Wrapper Gotchas</h3>
<pre><code class="lang-js">var a = new Boolean( false );

if (!a) {

    console.log( &quot;Oops&quot; ); // never runs
}</code></pre>
</section><section><h2 id="unboxing">Unboxing</h2>
<pre><code class="lang-js">var a = new String( &quot;abc&quot; );
var b = new Number( 42 );
var c = new Boolean( true );

a.valueOf(); // &quot;abc&quot;
b.valueOf(); // 42
c.valueOf(); // true</code></pre>
<p>Unboxing can also happen implicitly</p>
</section><section><h2 id="natives-as-constructors">Natives as Constructors</h2>
<ul>
<li>Arrays(..)</li>
<li><code>Object(..)</code>, <code>Function(..)</code>, and <code>RegExp(..)</code></li>
<li><code>Date(..)</code> and <code>Error(..)</code></li>
<li><code>Symbol(..)</code></li>
</ul>
</section><section><h3 id="arrays-">Arrays(..)</h3>
<pre><code class="lang-js">var a = new Array( 1, 2, 3 );
a; // [1, 2, 3]

var b = [1, 2, 3];
b; // [1, 2, 3]</code></pre>
</section><section><h3 id="sparse-arrays">Sparse Arrays</h3>
<pre><code class="lang-js">
var a = new Array( 3 );

a.length; // 3
a;

var a = new Array( 3 ); // [ undefined x 3 ]
var b = [ undefined, undefined, undefined ];
var c = [];
c.length = 3;

a; // [ undefined x 3 ]
b; // [ undefined, undefined, undefined ]
c; // []

a.join( &quot;-&quot; ); // &quot;--&quot;
b.join( &quot;-&quot; ); // &quot;--&quot;

a.map(function(v,i){ return i; }); // [ undefined x 3 ]
b.map(function(v,i){ return i; }); // [ 0, 1, 2 ]

var a = Array.apply( null, { length: 3 } );
a; // [ undefined, undefined, undefined ]</code></pre>
</section><section><h3 id="-object-function-and-regexp-"><code>Object(..)</code>, <code>Function(..)</code>, and <code>RegExp(..)</code></h3>
<pre><code class="lang-js">var c = new Object();
c.foo = &quot;bar&quot;;
c; // { foo: &quot;bar&quot; }

var d = { foo: &quot;bar&quot; };
d; // { foo: &quot;bar&quot; }

var e = new Function( &quot;a&quot;, &quot;return a * 2;&quot; );
var f = function(a) { return a * 2; };
function g(a) { return a * 2; }

var h = new RegExp( &quot;^a*b+&quot;, &quot;g&quot; );
var i = /^a*b+/g;

var name = &quot;Kyle&quot;;
//usage of constructor form
var namePattern = new RegExp( &quot;\\b(?:&quot; + name + &quot;)+\\b&quot;, &quot;ig&quot; );

var matches = someText.match( namePattern );</code></pre>
<p>Prefer literal form over <code>constructor</code></p>
</section><section><h3 id="-date-and-error-"><code>Date(..)</code> and <code>Error(..)</code></h3>
<p>No literal form</p>
<pre><code class="lang-js">if (!Date.now) {
    //emulate ES5 feature
    Date.now = function(){
        return (new Date()).getTime();
    };
}

var currentDate = Date.now();</code></pre>
</section><section><h3 id="-symbol-"><code>Symbol(..)</code></h3>
<pre><code class="lang-js">var mysym = Symbol( &quot;my own symbol&quot; );
mysym;                // Symbol(my own symbol)
mysym.toString();    // &quot;Symbol(my own symbol)&quot;
typeof mysym;         // &quot;symbol&quot;

var a = { };
a[mysym] = &quot;foobar&quot;;

Object.getOwnPropertySymbols( a );
// [ Symbol(my own symbol) ]</code></pre>
<p><code>Symbol</code>s are <em>not</em> <code>object</code>s, they are simple scalar primitives.</p>
</section><section><h3 id="native-prototypes">Native Prototypes</h3>
<p>Each of the built-in native constructors has its own <code>.prototype</code> object:</p>
<pre><code class="lang-js">// don&#39;t leave it that way, though, or expect weirdness!
// reset the `Array.prototype` to empty
Array.prototype.length = 0;</code></pre>
<p>Override native prototype is a bad idea</p>
</section><section><h2 id="review">Review</h2>
<ol>
<li>JS provides object wrappers around primitive values</li>
<li><code>&quot;abc&quot;.length</code> automatically boxes value with object wrapper </li>
</ol>
</section>
			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,
                slideNumber: true,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

				// Parallax scrolling
				// parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
				// parallaxBackgroundSize: '2100px 900px',

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});

		</script>

	</body>
</html>
