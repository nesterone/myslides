<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>You Don't Know JS - scope & closure</title>

		<meta name="description" content="scope & closure">
		<meta name="author" content="Igor Nesterenko">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.min.css">
		<link rel="stylesheet" href="css/theme/default.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', include the PDF print sheet -->
		<script>
			if( window.location.search.match( /print-pdf/gi ) ) {
				var link = document.createElement( 'link' );
				link.rel = 'stylesheet';
				link.type = 'text/css';
				link.href = 'css/print/pdf.css';
				document.getElementsByTagName( 'head' )[0].appendChild( link );
			}
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->

        <style type="text/css">
            .left-side {
                text-align: left;

            }
        </style>
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
                <section><h3 id="you-don-t-know-js-types-grammar">You Don&#39;t Know JS: Types &amp; Grammar</h3>
<h5 id="types-grammar">types &amp; grammar</h5>
<p>inspired by <a href="https://github.com/getify/You-Dont-Know-JS/tree/master/types%20%26%20grammar">getify</a></p>
</section><section><h3 id="presented-by">Presented by</h3>
<ul>
<li><a href="https://twitter.com/nesterone">Igor Nesterenko</a></li>
</ul>
</section><section><h3 id="high-level-overview">High-level Overview</h3>
<ul>
<li>Types</li>
<li>Values</li>
<li>Natives</li>
<li>Coercion</li>
</ul>
</section><section><h2 id="types">Types</h2>
<ul>
<li>What it&#39;s type ? Why does it matter ?</li>
<li>Built-in Types</li>
<li>Values as Types</li>
<li>Review</li>
</ul>
</section><section><h3 id="what-it-s-type-why-does-it-matter-">What it&#39;s type ? Why does it matter ?</h3>
<ul>
<li>These two values have different types.</li>
<li>There are many different ways that coercion can happen</li>
</ul>
</section><section><h3 id="built-in-types">Built-in Types</h3>
<ul>
<li><code>null</code></li>
<li><code>undefined</code></li>
<li><code>boolean</code></li>
<li><code>number</code></li>
<li><code>string</code></li>
<li><code>object</code></li>
<li><code>symbol</code> -- added in ES6!</li>
</ul>
</section><section><h3 id="the-typeof-">The &quot;typeof&quot;</h3>
<pre><code class="lang-js">typeof undefined     === &quot;undefined&quot;; // true
typeof true          === &quot;boolean&quot;;   // true
typeof 42            === &quot;number&quot;;    // true
typeof &quot;42&quot;          === &quot;string&quot;;    // true
typeof { life: 42 }  === &quot;object&quot;;    // true

// added in ES6!
typeof Symbol()      === &quot;symbol&quot;;    // true</code></pre>
</section><section><h3 id="-typeof-bug">&quot;typeof&quot; bug</h3>
<p><code>typeof null === &quot;object&quot;; // true</code></p>
</section><section><h3 id="-subtypes-of-object">&quot;Subtypes&quot; of object</h3>
<pre><code class="lang-js">typeof function a(){ /* .. */ } === &quot;function&quot;; // true, callable object
typeof [1,2,3] === &quot;object&quot;; // true</code></pre>
</section><section><h3 id="values-as-types">Values as Types</h3>
<p>In JavaScript, variables don&#39;t have types -- <strong>values have types</strong></p>
</section><section><h3 id="-undefined-vs-undeclared-"><code>undefined</code> vs &quot;undeclared&quot;</h3>
<p>In JavaScript, they&#39;re quite different</p>
<pre><code class="lang-js">var a;

typeof a; // &quot;undefined&quot;
typeof b; // &quot;undefined&quot;, safety guard

a; // undefined
b; // ReferenceError: b is not defined</code></pre>
</section><section><h3 id="-typeof-undeclared"><code>typeof</code> Undeclared</h3>
<ul>
<li>feature detection </li>
<li>different JS environments</li>
<li>different modes: development, production</li>
</ul>
<pre><code class="lang-js">
// this is a safe existence check
if (typeof DEBUG !== &quot;undefined&quot;) {
    console.log( &quot;Debugging is starting&quot; );
}

// this is a safe existence check
if (typeof someApi !== &quot;undefined&quot;){
    simeApi.runIt();
}</code></pre>
</section><section><h3 id="review">Review</h3>
<ul>
<li>seven build-in types</li>
<li><code>undefined</code> and &quot;undeclared&quot; are different</li>
<li>usage of <code>typeof</code> for safe existence check</li>
</ul>
</section><section><h2 id="values">Values</h2>
<ul>
<li>Arrays</li>
<li>Strings</li>
<li>Numbers</li>
<li>Special Values</li>
<li>Values vs. Reference</li>
<li>Review</li>
</ul>
</section><section><h2 id="arrays">Arrays</h2>
<ul>
<li>Arrays</li>
<li>Array-Likes</li>
</ul>
</section><section><h3 id="arrays">Arrays</h3>
<pre><code class="lang-js">
var a = [ 1, &quot;2&quot;, [3] ];

a.length;        // 3
a[0] === 1;        // true
a[2][0] === 3;    // true

a.length;    // 0

a[0] = 1;
a[1] = &quot;2&quot;;
a[2] = [ 3 ];

a.length;    // 3</code></pre>
</section><section><h3 id="-sparse-arrays">&quot;Sparse&quot; Arrays</h3>
<pre><code class="lang-js">var a = [ ];

a[0] = 1;
// no `a[1]` slot set here
a[2] = [ 3 ];

a[1];        // undefined

a.length;    // 3</code></pre>
</section><section><h3 id="string-ad-index">String ad Index</h3>
<pre><code class="lang-js">var a = [ ];

a[&quot;13&quot;] = 42; // coersion from string to number

a.length; // 14</code></pre>
<p>use number for index</p>
</section><section><h3 id="array-likes">Array-Likes</h3>
<ul>
<li>&#39;arguments&#39; in function</li>
<li>some of DOM elements (NodesList)</li>
</ul>
<pre><code class="lang-js">function foo() {
    var arr = Array.prototype.slice.call( arguments );
    arr.push( &quot;bam&quot; );
    console.log( arr );
}

foo( &quot;bar&quot;, &quot;baz&quot; ); // [&quot;bar&quot;,&quot;baz&quot;,&quot;bam&quot;]

// in ES6

var arr = Array.from( arguments );</code></pre>
</section><section><h3 id="string">String</h3>
<ul>
<li>Arrays and Strings Similarities</li>
<li>Arrays and String Differences</li>
<li>Reuse of Methods from Arrays</li>
</ul>
</section><section><h3 id="arrays-and-strings-similarities">Arrays and Strings Similarities</h3>
<pre><code class="lang-js">var a = &quot;foo&quot;;
var b = [&quot;f&quot;,&quot;o&quot;,&quot;o&quot;];

a.length;                            // 3
b.length;                            // 3

a.indexOf( &quot;o&quot; );                    // 1
b.indexOf( &quot;o&quot; );                    // 1

var c = a.concat( &quot;bar&quot; );            // &quot;foobar&quot;
var d = b.concat( [&quot;b&quot;,&quot;a&quot;,&quot;r&quot;] );    // [&quot;f&quot;,&quot;o&quot;,&quot;o&quot;,&quot;b&quot;,&quot;a&quot;,&quot;r&quot;]

a === c;                            // false
b === d;                            // false

a;                                    // &quot;foo&quot;
b;                                    // [&quot;f&quot;,&quot;o&quot;,&quot;o&quot;]</code></pre>
</section><section><h3 id="strings-are-immutable">Strings are immutable</h3>
<pre><code class="lang-js">a[1] = &quot;O&quot;;
b[1] = &quot;O&quot;;

a; // &quot;foo&quot;
b; // [&quot;f&quot;,&quot;O&quot;,&quot;o&quot;];

c = a.toUpperCase();
a === c;    // false
a;            // &quot;foo&quot;
c;            // &quot;FOO&quot;

b.push( &quot;!&quot; );
b;            // [&quot;f&quot;,&quot;O&quot;,&quot;o&quot;,&quot;!&quot;]</code></pre>
</section><section><h3 id="reuse-of-methods-from-arrays">Reuse of Methods from Arrays</h3>
<ul>
<li>&quot;borrow&quot; non-mutation array methods </li>
</ul>
<pre><code class="lang-js">a.join;            // undefined
a.map;            // undefined

var c = Array.prototype.join.call( a, &quot;-&quot; );
var d = Array.prototype.map.call( a, function(v){
    return v.toUpperCase() + &quot;.&quot;;
} ).join( &quot;&quot; );

c;                // &quot;f-o-o&quot;
d;                // &quot;F.O.O.&quot;</code></pre>
</section><section><h2 id="numbers">Numbers</h2>
<ul>
<li>Numeric Syntax</li>
<li>Small Decimal Values</li>
<li>Safe Integer Ranges</li>
<li>Testing for Integers</li>
<li>32-bit (Signed) Integers</li>
</ul>
</section><section><h3 id="numbers">Numbers</h3>
<p>In JS we have only Numbers. &quot;IEEE 754&quot; standard, often called &quot;floating-point.&quot;</p>
</section><section><h3 id="numeric-syntax">Numeric Syntax</h3>
<pre><code class="lang-js">var a = 42;     // base-10 decimal literals
var b = 42.3;
var c1 = 0.3;   
var c2 = .3;    // valid
var d1 = 42.0
var d2 = 42.    // valid</code></pre>
</section><section><h3 id="exponent-form">Exponent Form</h3>
<pre><code class="lang-js">var a = 5E10;
a;                    // 50000000000
a.toExponential();    // &quot;5e+10&quot;

var b = a * a;      // very large numbers
b;                    // 2.5e+21

var c = 1 / a;
c;                    // 2e-11</code></pre>
</section><section><h3 id="fixed-and-precision">Fixed and Precision</h3>
<pre><code class="lang-js">var a = 42.59;

a.toFixed( 0 ); // &quot;43&quot;
a.toFixed( 1 ); // &quot;42.6&quot;
a.toFixed( 2 ); // &quot;42.59&quot;
a.toFixed( 3 ); // &quot;42.590&quot;
a.toFixed( 4 ); // &quot;42.5900&quot;

a.toPrecision( 1 ); // &quot;4e+1&quot;
a.toPrecision( 2 ); // &quot;43&quot;
a.toPrecision( 3 ); // &quot;42.6&quot;
a.toPrecision( 4 ); // &quot;42.59&quot;
a.toPrecision( 5 ); // &quot;42.590&quot;
a.toPrecision( 6 ); // &quot;42.5900&quot;</code></pre>
</section><section><h3 id="other-bases">Other Bases</h3>
<pre><code class="lang-js">0xf3; // hexadecimal for: 243
0Xf3; // ditto

0363; // octal for: 243, doesn&#39;t allowed in strict mode

//ES 6
0o363;        // octal for: 243
0O363;        // or

0b11110011;    // binary for: 243
0B11110011; // or</code></pre>
</section><section><h3 id="small-decimal-values">Small Decimal Values</h3>
<ul>
<li>all languages based on &quot;IEEE 754&quot;</li>
</ul>
<pre><code class="lang-js">0.1 + 0.2 === 0.3; // false</code></pre>
</section><section><h3 id="compare-small-decimal-values">Compare Small Decimal Values</h3>
<pre><code class="lang-js">if (!Number.EPSILON) {
    //emulate ES6
    Number.EPSILON = Math.pow(2,-52);
}

function numbersCloseEnoughToEqual(n1,n2) {
    return Math.abs( n1 - n2 ) &lt; Number.EPSILON;
}

var a = 0.1 + 0.2;
var b = 0.3;

numbersCloseEnoughToEqual( a, b );                    // true
numbersCloseEnoughToEqual( 0.0000001, 0.0000002 );    // fals</code></pre>
</section><section><h3 id="safe-integer-ranges">Safe Integer Ranges</h3>
<ul>
<li>Number.MAX_VALUE and Number.MIN_VALUE - not quite useful</li>
<li>ES6 Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER</li>
<li>Big numbers may get official support soon</li>
</ul>
</section><section><h3 id="testing-for-integers">Testing for Integers</h3>
<pre><code class="lang-js">if (!Number.isInteger) {
    //emulate ES6
    Number.isInteger = function(num) {
        return typeof num == &quot;number&quot; &amp;&amp; num % 1 == 0;
    };
}

Number.isInteger( 42 );        // true
Number.isInteger( 42.000 );    // true
Number.isInteger( 42.3 );    // false</code></pre>
</section><section><h3 id="32-bit-signed-integers">32-bit (Signed) Integers</h3>
<ul>
<li>64-bit Floating Point</li>
<li>bitwise operation only in 32-bit</li>
</ul>
</section><section><h2 id="special-values">Special Values</h2>
<ul>
<li>The Non-value Values</li>
<li>Undefined</li>
<li>Special Numbers</li>
<li>Special Equality</li>
</ul>
</section><section><h3 id="the-non-value-values">The Non-value Values</h3>
<ul>
<li><code>null</code> is an empty value</li>
<li><code>undefined</code> is a missing value</li>
</ul>
<p>Or:</p>
<ul>
<li><code>undefined</code> hasn&#39;t had a value yet</li>
<li><code>null</code> had a value and doesn&#39;t anymore</li>
</ul>
</section><section><h3 id="undefined">Undefined</h3>
<pre><code class="lang-js">
function foo() {
    undefined = 2; // really bad idea!
}

foo();</code></pre>
</section><section><h3 id="undefined">Undefined</h3>
<pre><code class="lang-js">
function foo() {
    &quot;use strict&quot;;
    undefined = 2; // TypeError!
}

foo();</code></pre>
</section><section><h3 id="undefined">Undefined</h3>
<pre><code class="lang-js">
function foo() {
    &quot;use strict&quot;;
    var undefined = 2;
    console.log( undefined ); // 2
}

foo();</code></pre>
<p><strong>Friends don&#39;t let friends override <code>undefined</code>.</strong> Ever.</p>
</section><section><h3 id="-void-operator"><code>void</code> Operator</h3>
<p>The expression <code>void ___</code> &quot;voids&quot; out any value (undefined)</p>
<pre><code class="lang-js">function doSomething() {
    // note: `APP.ready` is provided by our application
    if (!APP.ready) {
        // try again later
        return void setTimeout( doSomething, 100 );
    }

    var result;

    // do some other stuff
    return result;
}

// were we able to do it right away?
if (doSomething()) {
    // handle next tasks right away
}</code></pre>
</section><section><h3 id="special-numbers">Special Numbers</h3>
<p>The <code>number</code> type includes several special values. We&#39;ll take a look at each in detail.</p>
</section><section><h3 id="the-not-number-number">The Not Number, Number</h3>
<p><code>NaN</code> literally stands for &quot;not a <code>number</code>&quot;</p>
<pre><code class="lang-js">var a = 2 / &quot;foo&quot;;        // NaN

typeof a === &quot;number&quot;;    // true

a == NaN;    // false
a === NaN;    // false</code></pre>
</section><section><h3 id="19-years-isnan-bug">19 years <code>isNaN</code> bug</h3>
<pre><code class="lang-js">var a = 2 / &quot;foo&quot;;
var b = &quot;foo&quot;;

a; // NaN
b; // &quot;foo&quot;

window.isNaN( a ); // true
window.isNaN( b ); // true -- ouch!

if (!Number.isNaN) {
    // emulate ES6
    Number.isNaN = function(n) {
        return (
            typeof n === &quot;number&quot; &amp;&amp;
            window.isNaN( n )
        );
    };
}

var a = 2 / &quot;foo&quot;;
var b = &quot;foo&quot;;

Number.isNaN( a ); // true
Number.isNaN( b ); // false -- phew!</code></pre>
</section><section><h3 id="infinities">Infinities</h3>
<pre><code class="lang-js">var a = 1 / 0;    // Infinity, yep not an error
var b = -1 / 0;    // -Infinity

var a = Number.MAX_VALUE;    // 1.7976931348623157e+308
a + a;                        // Infinity
a + Math.pow( 2, 970 );        // Infinity
a + Math.pow( 2, 969 );        // 1.7976931348623157e+308</code></pre>
</section><section><h3 id="zeros">Zeros</h3>
<pre><code class="lang-js">var a = 0 / -3; // -0
var b = 0 * -3; // -0

var a = 0 / -3;

// (some browser) consoles at least get it right
a;                            // -0

// but the spec insists on lying to you!
a.toString();                // &quot;0&quot;
a + &quot;&quot;;                        // &quot;0&quot;
String( a );                // &quot;0&quot;

// strangely, even JSON gets in on the deception
JSON.stringify( a );        // &quot;0&quot;

-0 == 0;    // true
+0 == 0;   // true
-0 === 0;    // true
+0 === 0;   // true</code></pre>
</section><section><h3 id="distinguish-zeros">Distinguish Zeros</h3>
<pre><code class="lang-js">function isNegZero(n) {
    n = Number( n );
    return (n === 0) &amp;&amp; (1 / n === -Infinity);
}

isNegZero( -0 );        // true
isNegZero( 0 / -3 );    // true
isNegZero( 0 );            // false</code></pre>
</section><section><h3 id="special-equality-for-tricky-cases-">Special Equality (for tricky cases)</h3>
<pre><code class="lang-js">if (!Object.is) {
    // emulate ES6
    Object.is = function(v1, v2) {
        // test for `-0`
        if (v1 === 0 &amp;&amp; v2 === 0) {
            return 1 / v1 === 1 / v2;
        }
        // test for `NaN`
        if (v1 !== v1) {
            return v2 !== v2;
        }
        // everything else
        return v1 === v2;
    };
}

var a = 2 / &quot;foo&quot;;
var b = -3 * 0;

Object.is( a, NaN );    // true
Object.is( b, -0 );        // true

Object.is( b, 0 );        // false</code></pre>
</section><section><h2 id="value-vs-reference">Value vs. Reference</h2>
<p>In JavaScript, there are no pointers</p>
</section><section><h3 id="value-copy">Value Copy</h3>
<pre><code class="lang-js">var a = 2;
var b = a; // `b` is always a copy of the value in `a`
b++;
a; // 2
b; // 3</code></pre>
<p>All simple values: <code>null</code>, <code>undefined</code>, <code>string</code>, <code>number</code>, <code>boolean</code>, and ES6&#39;s <code>symbol</code>.</p>
</section><section><h3 id="reference-copy">Reference Copy</h3>
<pre><code class="lang-js">var c = [1,2,3];
var d = c; // `d` is a reference to the shared `[1,2,3]` value
d.push( 4 );
c; // [1,2,3,4]
d; // [1,2,3,4]</code></pre>
<p>For Objects</p>
</section><section><h3 id="common-confusions-with-function-parameters">Common Confusions With Function Parameters</h3>
<pre><code class="lang-js">function foo(x) {
    x.push( 4 );
    x; // [1,2,3,4]

    // later
    x = [4,5,6];
    x.push( 7 );
    x; // [4,5,6,7]
}

var a = [1,2,3];

foo( a );

a; // [1,2,3,4]  not  [4,5,6,7]</code></pre>
</section><section><h3 id="common-confusions-with-function-parameters">Common Confusions With Function Parameters</h3>
<pre><code class="lang-js">function foo(x) {
    x = x + 1;
    x; // 3
}

var a = 2;
var b = new Number( a ); // or equivalently `Object(a)`

foo( b );
console.log( b ); // 2, not 3</code></pre>
<p>primitive value is <em>not mutable</em>, even boxed (wrapped in an object)</p>
</section><section><h2 id="review">Review</h2>
<ol>
<li><code>array</code>s are simply numerically indexed collections of any value-type</li>
<li>Numbers in JavaScript include both &quot;integers&quot; and floating-point values</li>
<li>The <code>null</code> type has just one value: <code>null</code></li>
<li><code>undefined</code> is basically the default value</li>
<li><code>void</code> operator lets you create the <code>undefined</code> value from any other value</li>
<li><code>number</code>s include several special values, like <code>NaN</code>, <code>+Infinity</code>, <code>-Infinity</code>, <code>-0</code></li>
<li>Simple values assigned/passed by <code>value-copy</code></li>
<li>Compound values assigned/passed by <code>reference-copy</code></li>
</ol>
</section><section><h2 id="natives">Natives</h2>
<ul>
<li>Internal <code>[[Class]]</code></li>
<li>Boxing Wrappers</li>
<li>Unboxing</li>
<li>Natives as Constructors</li>
<li>Review</li>
</ul>
</section><section><h3 id="list-of-natives">List of Natives</h3>
<ul>
<li><code>String()</code></li>
<li><code>Number()</code></li>
<li><code>Boolean()</code></li>
<li><code>Array()</code></li>
<li><code>Object()</code></li>
<li><code>Function()</code></li>
<li><code>RegExp()</code></li>
<li><code>Date()</code></li>
<li><code>Error()</code></li>
<li><code>Symbol()</code> -- added in ES6!</li>
</ul>
</section><section><h3 id="object-wrappers-around-primitives">Object wrappers around primitives</h3>
<pre><code class="lang-js">var a = new String( &quot;abc&quot; );

typeof a; // &quot;object&quot; ... not &quot;String&quot;

a instanceof String; // true

Object.prototype.toString.call( a ); // &quot;[object String]&quot;</code></pre>
</section><section><h3 id="internal-class-">Internal <code>[[Class]]</code></h3>
<p>Internal <em>class</em> classification rather than related to classes from traditional class-oriented coding</p>
<pre><code class="lang-js">Object.prototype.toString.call( [1,2,3] );            // &quot;[object Array]&quot;
Object.prototype.toString.call( /regex-literal/i );    // &quot;[object RegExp]&quot;

Object.prototype.toString.call( null );            // &quot;[object Null]&quot;
Object.prototype.toString.call( undefined );    // &quot;[object Undefined]&quot;

Object.prototype.toString.call( &quot;abc&quot; );    // &quot;[object String]&quot;
Object.prototype.toString.call( 42 );        // &quot;[object Number]&quot;
Object.prototype.toString.call( true );        // &quot;[object Boolean]&quot;</code></pre>
</section><section><h3 id="boxing-wrappers">Boxing Wrappers</h3>
<pre><code class="lang-js">var a = &quot;abc&quot;;

a.length; // 3
a.toUpperCase(); // &quot;ABC&quot;</code></pre>
<p>It&#39;s better to just let the boxing happen implicitly where necessary</p>
</section><section><h3 id="object-wrapper-gotchas">Object Wrapper Gotchas</h3>
<pre><code class="lang-js">var a = new Boolean( false );

if (!a) {

    console.log( &quot;Oops&quot; ); // never runs
}</code></pre>
</section><section><h2 id="unboxing">Unboxing</h2>
<pre><code class="lang-js">var a = new String( &quot;abc&quot; );
var b = new Number( 42 );
var c = new Boolean( true );

a.valueOf(); // &quot;abc&quot;
b.valueOf(); // 42
c.valueOf(); // true</code></pre>
<p>Unboxing can also happen implicitly</p>
</section><section><h2 id="natives-as-constructors">Natives as Constructors</h2>
<ul>
<li>Arrays(..)</li>
<li><code>Object(..)</code>, <code>Function(..)</code>, and <code>RegExp(..)</code></li>
<li><code>Date(..)</code> and <code>Error(..)</code></li>
<li><code>Symbol(..)</code></li>
</ul>
</section><section><h3 id="arrays-">Arrays(..)</h3>
<pre><code class="lang-js">var a = new Array( 1, 2, 3 );
a; // [1, 2, 3]

var b = [1, 2, 3];
b; // [1, 2, 3]</code></pre>
</section><section><h3 id="sparse-arrays">Sparse Arrays</h3>
<pre><code class="lang-js">
var a = new Array( 3 );

a.length; // 3
a;

var a = new Array( 3 ); // [ undefined x 3 ]
var b = [ undefined, undefined, undefined ];
var c = [];
c.length = 3;

a; // [ undefined x 3 ]
b; // [ undefined, undefined, undefined ]
c; // []

a.join( &quot;-&quot; ); // &quot;--&quot;
b.join( &quot;-&quot; ); // &quot;--&quot;

a.map(function(v,i){ return i; }); // [ undefined x 3 ]
b.map(function(v,i){ return i; }); // [ 0, 1, 2 ]

var a = Array.apply( null, { length: 3 } );
a; // [ undefined, undefined, undefined ]</code></pre>
</section><section><h3 id="-object-function-and-regexp-"><code>Object(..)</code>, <code>Function(..)</code>, and <code>RegExp(..)</code></h3>
<pre><code class="lang-js">var c = new Object();
c.foo = &quot;bar&quot;;
c; // { foo: &quot;bar&quot; }

var d = { foo: &quot;bar&quot; };
d; // { foo: &quot;bar&quot; }

var e = new Function( &quot;a&quot;, &quot;return a * 2;&quot; );
var f = function(a) { return a * 2; };
function g(a) { return a * 2; }

var h = new RegExp( &quot;^a*b+&quot;, &quot;g&quot; );
var i = /^a*b+/g;

var name = &quot;Kyle&quot;;
//usage of constructor form
var namePattern = new RegExp( &quot;\\b(?:&quot; + name + &quot;)+\\b&quot;, &quot;ig&quot; );

var matches = someText.match( namePattern );</code></pre>
<p>Prefer literal form over <code>constructor</code></p>
</section><section><h3 id="-date-and-error-"><code>Date(..)</code> and <code>Error(..)</code></h3>
<p>No literal form</p>
<pre><code class="lang-js">if (!Date.now) {
    //emulate ES5 feature
    Date.now = function(){
        return (new Date()).getTime();
    };
}

var currentDate = Date.now();</code></pre>
</section><section><h3 id="-symbol-"><code>Symbol(..)</code></h3>
<pre><code class="lang-js">var mysym = Symbol( &quot;my own symbol&quot; );
mysym;                // Symbol(my own symbol)
mysym.toString();    // &quot;Symbol(my own symbol)&quot;
typeof mysym;         // &quot;symbol&quot;

var a = { };
a[mysym] = &quot;foobar&quot;;

Object.getOwnPropertySymbols( a );
// [ Symbol(my own symbol) ]</code></pre>
<p><code>Symbol</code>s are <em>not</em> <code>object</code>s, they are simple scalar primitives.</p>
</section><section><h3 id="native-prototypes">Native Prototypes</h3>
<p>Each of the built-in native constructors has its own <code>.prototype</code> object:</p>
<pre><code class="lang-js">// don&#39;t leave it that way, though, or expect weirdness!
// reset the `Array.prototype` to empty
Array.prototype.length = 0;</code></pre>
<p>Override native prototype is a bad idea</p>
</section><section><h2 id="review">Review</h2>
<ol>
<li>JS provides object wrappers around primitive values</li>
<li><code>&quot;abc&quot;.length</code> automatically boxes value with object wrapper </li>
</ol>
</section><section><h2 id="coercion">Coercion</h2>
<ul>
<li>Converting Values</li>
<li>Abstract Value Operations</li>
<li>Explicit Coercion</li>
<li>Implicit Coercion</li>
<li>Loose Equals vs. Strict Equals</li>
<li>Abstract Relation Comparison</li>
<li>Review</li>
</ul>
</section><section><h2 id="coercion">Coercion</h2>
<p>Our goal is to fully explore the pros and cons (yes, there <em>are</em> pros!) of coercion</p>
</section><section><h2 id="converting-values">Converting Values</h2>
<ul>
<li>&quot;type casting&quot;  in statically typed languages at compile time</li>
<li>&quot;type coercion&quot; in runtime for dynamically typed languages</li>
<li>&quot;explicit&quot; and &quot;implicit&quot; coercions are &#39;relative&#39;</li>
</ul>
<pre><code class="lang-js">var a = 42;

var b = a + &quot;&quot;;            // implicit coercion

var c = String( a );    // explicit coercion</code></pre>
</section><section><h2 id="abstract-value-operations">Abstract Value Operations</h2>
<ul>
<li>ToString<ul>
<li>JSON Stringification</li>
</ul>
</li>
<li>ToNumber</li>
<li>ToBoolean</li>
</ul>
</section><section><h2 id="abstract-value-operations">Abstract Value Operations</h2>
<p>ES5 defines 6 several &quot;abstract operations&quot;</p>
<p>Let&#39;s pay attention to: </p>
<p>ToString, ToNumber, ToBoolean and a bit in ToPrimitive</p>
</section><section><h3 id="tostring">ToString</h3>
<pre><code class="lang-js">
String(null);      //&quot;null&quot;
String(undefined); //&quot;undefined&quot;

// multiplying `1.07` by `1000`, seven times over
var a = 1.07 * 1000 * 1000 * 1000 * 1000 * 1000 * 1000 * 1000;

// seven times three digits =&gt; 21 digits
a.toString(); // &quot;1.07e21&quot;

var b = {};

console.log(b);  //  Object.prototype.toString() -&gt; [object Object]

var arr = [1,2,3];

arr.toString(); // &quot;1,2,3&quot;</code></pre>
</section><section><h3 id="json-stringification">JSON Stringification</h3>
<ol>
<li><code>string</code>, <code>number</code>, <code>boolean</code> converted via <code>ToString</code> abstract operation.</li>
<li><code>toJSON()</code> method is automatically called to (sort of) &quot;coerce&quot; the object to be <em>JSON-safe</em> before stringification.</li>
</ol>
</section><section><h3 id="json-safe-stringification">JSON-safe stringification</h3>
<pre><code class="lang-js">var o = { };

var a = {
    b: 42,
    c: o,
    d: function(){}
};

// create a circular reference inside `a`
o.e = a;

// would throw an error on the circular reference
// JSON.stringify( a );

// define a custom JSON value serialization
a.toJSON = function() {
    // only include the `b` property for serialization
    return { b: this.b };
};

JSON.stringify( a ); // &quot;{&quot;b&quot;:42}&quot;</code></pre>
</section><section><h3 id="tonumber">ToNumber</h3>
<ol>
<li><code>true</code> -&gt; 1, <code>false</code> -&gt; 0</li>
<li><code>string</code> -&gt; <code>NaN</code>, if can&#39;t pars to <code>number</code>, treats &#39;0&#39; in the beginning of string as 8-base number</li>
<li>Objects(and arrays) run <code>ToPrimitive</code> first<ul>
<li><code>ToPrimitive</code> search for <code>valueOf</code>, if not then <code>toString</code>, otherwise throws <code>TypeError</code></li>
</ul>
</li>
</ol>
</section><section><h3 id="override-valueof-">Override <code>valueOf</code></h3>
<pre><code class="lang-js">var a = {
    valueOf: function(){
        return &quot;42&quot;;
    }
};

var b = {
    toString: function(){
        return &quot;42&quot;;
    }
};

var c = [4,2];
c.toString = function(){
    return this.join( &quot;&quot; );    // &quot;42&quot;
};

Number( a );            // 42
Number( b );            // 42
Number( c );            // 42
Number( &quot;&quot; );            // 0
Number( [] );            // 0
Number( [ &quot;abc&quot; ] );    // NaN</code></pre>
</section><section><h3 id="toboolean">ToBoolean</h3>
<p>Lots of confusions and misconceptions</p>
<ul>
<li>Falsy Values</li>
<li>Falsy Objects</li>
</ul>
</section><section><h3 id="falsy-values">Falsy Values</h3>
<ul>
<li><code>undefined</code></li>
<li><code>null</code></li>
<li><code>false</code></li>
<li><code>+0</code>, <code>-0</code>, and <code>NaN</code></li>
<li><code>&quot;&quot;</code></li>
</ul>
<p>Everything else truthy</p>
</section><section><h3 id="falsy-objects">Falsy Objects</h3>
<pre><code class="lang-js">
Boolean({});            // true
Boolean(document.all);  // false, WHAT!?</code></pre>
</section><section><h2 id="explicit-coercion">Explicit Coercion</h2>
<p>Make it clear and obvious that we converting value of one type to another type</p>
<ul>
<li>Explicitly: Strings &lt;--&gt; Numbers</li>
<li>Explicitly: Parsing Numeric Strings</li>
<li>Explicitly: * --&gt; Boolean</li>
</ul>
</section><section><h3 id="explicitly-strings-numbers">Explicitly: Strings &lt;--&gt; Numbers</h3>
<ol>
<li><code>String</code> and <code>Number</code> functions without <code>new</code></li>
<li><code>toString()</code></li>
<li>Unary operator +/-, however avoid their usage</li>
</ol>
<pre><code class="lang-js">var a = 42;
var b = String( a );    // &quot;42&quot;

var c = &quot;3.14&quot;;
var d = Number( c );    // 3.14

var a1 = 42;
var b1 = a.toString();  // &quot;42&quot;

var c1 = &quot;3.14&quot;;
var d1 = +c;            // 3.14


var c = &quot;3.14&quot;;
var d = 5+ +c;          // 8.14

1 + - + + + - + 1;        // 2</code></pre>
</section><section><h3 id="data-to-number">Data To number</h3>
<p>Because data object coerced to timestamp</p>
<pre><code class="lang-js">var d = new Date( &quot;Mon, 18 Aug 2014 08:53:06 CDT&quot; );

+d; // 1408369986000

var timestamp = +new Date();
var timestamp1 = new Date().getTime();

if (!Date.now) {
    // emulate ES5 
    Date.now = function() {
        return +new Date();
    };
}

var timestamp2 = Date.new();</code></pre>
</section><section><h3 id="the-curious-case-of-the-">The Curious Case of the ~</h3>
<ol>
<li><code>~</code> aka &quot;bitwise NOT&quot;</li>
<li>Run <code>ToInt32</code></li>
<li><code>~x</code> is roughly the same as <code>-(x+1)</code></li>
</ol>
<pre><code class="lang-js">~42;    // -(42+1) ==&gt; -43

var a = &quot;Hello World&quot;;

~a.indexOf( &quot;lo&quot; );            // -4   &lt;-- truthy!

if (~a.indexOf( &quot;lo&quot; )) {    // true
    // found it!
}

~a.indexOf( &quot;ol&quot; );            // 0    &lt;-- falsy!
!~a.indexOf( &quot;ol&quot; );        // true

if (!~a.indexOf( &quot;ol&quot; )) {    // true
    // not found!
}</code></pre>
</section><section><h3 id="explicitly-parsing-numeric-strings">Explicitly: Parsing Numeric Strings</h3>
<ol>
<li>Separate parsing from coercion</li>
<li>Never use non-string values with <code>parseInt</code></li>
</ol>
<pre><code class="lang-js">var a = &quot;42&quot;;
var b = &quot;42px&quot;;

Number( a );    // 42
parseInt( a );    // 42

Number( b );    // NaN
parseInt( b );    // 42

var obj = {
    num: 21,
    toString: function() { return String( this.num * 2 ); }
};

parseInt( obj ); // 42

parseInt( 1/0, 19 ); // 18
parseInt( 0.000008 );        // 0   (&quot;0&quot; from &quot;0.000008&quot;)
parseInt( 0.0000008 );        // 8   (&quot;8&quot; from &quot;8e-7&quot;)
parseInt( false, 16 );        // 250 (&quot;fa&quot; from &quot;false&quot;)
parseInt( parseInt, 16 );    // 15  (&quot;f&quot; from &quot;function..&quot;)
parseInt( &quot;0x10&quot; );            // 16
parseInt( &quot;103&quot;, 2 );        // 2</code></pre>
</section><section><h3 id="explicitly-boolean">Explicitly: * --&gt; Boolean</h3>
<ol>
<li><code>Boolean</code> without <code>new</code></li>
<li><code>!!</code> double-negate operator</li>
</ol>
<pre><code class="lang-js">var a = &quot;0&quot;;
var b = [];
var c = {};

var d = &quot;&quot;;
var e = 0;
var f = null;
var g;

Boolean( a ); // true
!!a;          // true
Boolean( b ); // true
!!b;          // true
Boolean( c ); // true
!!c;          // true

Boolean( d ); // false
!!d           // false
Boolean( e ); // false
!!e;          // false
Boolean( f ); // false
!!f;          // false
Boolean( g ); // false
!!g;</code></pre>
</section><section><h2 id="implicit-coercion">Implicit Coercion</h2>
<p><em>Implicit</em> coercion refers to type conversions that are hidden</p>
<ul>
<li>Simplifying Implicitly</li>
<li>Implicitly: Strings &lt;--&gt; Numbers</li>
<li>Implicitly: Booleans --&gt; Numbers</li>
<li>Implicitly: * --&gt; Boolean</li>
<li>Operators <code>||</code> and <code>&amp;&amp;</code></li>
<li>Symbol Coercion</li>
</ul>
</section><section><h3 id="simplifying-implicitly">Simplifying Implicitly</h3>
<p>Don&#39;t assume <em>implicit</em> coercion is ALL bad</p>
<pre><code class="lang-js">SomeType x = SomeType( AnotherType( y ) )

//over 

SomeType x = SomeType( y )</code></pre>
</section><section><h3 id="implicitly-strings-numbers">Implicitly: Strings &lt;--&gt; Numbers</h3>
<ol>
<li><code>number</code> to <code>string</code> with <code>a+b</code>, if object, then run <code>ToPrimitive</code>-&gt;<code>ToNumber</code>-&gt;<code>toString</code></li>
<li><code>string</code> to <code>number</code> with <code>a-b</code>, it runs  <code>ToNumber</code></li>
</ol>
<pre><code class="lang-js">var a = &quot;42&quot;;
var b = &quot;0&quot;;

var c = 42;
var d = 0;

a + b; // &quot;420&quot;
c + d; // 42

var a1 = [1,2];
var b1 = [3,4];

a1 + b1; // &quot;1,23,4&quot;

var a2 = 42;
var b2 = a2 + &quot;&quot;;

b2; // &quot;42&quot;

var a3 = {
    valueOf: function() { return 42; },
    toString: function() { return 4; }
};

a3 + &quot;&quot;;            // &quot;42&quot;

String( a3 );    // &quot;4&quot;

var a4 = &quot;3.14&quot;;
var b4 = a - 0;

b4; // 3.14</code></pre>
</section><section><h3 id="implicitly-booleans-numbers">Implicitly: Booleans --&gt; Numbers</h3>
<pre><code class="lang-js">function onlyOne() {
    var sum = 0;
    for (var i=0; i &lt; arguments.length; i++) {
        // skip falsy values. same as treating
        // them as 0&#39;s, but avoids NaN&#39;s.
        if (arguments[i]) {
            sum += arguments[i]; // sum += Number(arguments[i]);
        }
    }
    return sum == 1;
}

var a = true;
var b = false;

onlyOne( b, a );                // true
onlyOne( b, a, b, b, b );        // true

onlyOne( b, b );                // false
onlyOne( b, a, b, b, b, a );    // false</code></pre>
</section><section><h3 id="implicitly-boolean">Implicitly: * --&gt; Boolean</h3>
<ol>
<li>The test expression in an <code>if (..)</code> statement.</li>
<li>The test expression (second clause) in a <code>for ( .. ; .. ; .. )</code> header.</li>
<li>The test expression in <code>while (..)</code> and <code>do..while(..)</code> loops.</li>
<li>The test expression (first clause) in <code>? :</code> ternary expressions.</li>
<li>The left-hand operand (which serves as a test expression -- see below!) to the <code>||</code> (&quot;logical or&quot;) and <code>&amp;&amp;</code> (&quot;logical and&quot;) operators.</li>
</ol>
</section><section><h3 id="implicitly-boolean">Implicitly: * --&gt; Boolean</h3>
<pre><code class="lang-js">var a = 42;
var b = &quot;abc&quot;;
var c;
var d = null;
if (a) {
    console.log( &quot;yep&quot; );        // yep
}
while (c) {
    console.log( &quot;nope, never runs&quot; );
}
c = d ? a : b;
c;                                // &quot;abc&quot;

if ((a &amp;&amp; d) || c) {
    console.log( &quot;yep&quot; );        // yep
}</code></pre>
</section><section><h3 id="operators-and-">Operators <code>||</code> and <code>&amp;&amp;</code></h3>
<p>Select one of the two operand&#39;s values</p>
<pre><code class="lang-js">var a = 42;
var b = &quot;abc&quot;;
var c = null;

a || b;        // 42
a &amp;&amp; b;        // &quot;abc&quot;

c || b;        // &quot;abc&quot;
c &amp;&amp; b;        // null

a || b;
// roughly equivalent to:
a ? a : b;

a &amp;&amp; b;
// roughly equivalent to:
a ? b : a;</code></pre>
</section><section><h3 id="backup-defaults">Backup Defaults</h3>
<pre><code class="lang-js">function foo(a,b) {
    a = a || &quot;hello&quot;;
    b = b || &quot;world&quot;;

    console.log( a + &quot; &quot; + b );
}

foo();                    // &quot;hello world&quot;
foo( &quot;yeah&quot;, &quot;yeah!&quot; );    // &quot;yeah yeah!&quot;

foo( &quot;That&#39;s it!&quot;, &quot;&quot; ); // &quot;That&#39;s it! world&quot; &lt;-- Oops!</code></pre>
</section><section><h3 id="guard-operator">Guard Operator</h3>
<pre><code class="lang-js">function foo() {
    console.log( a );
}

var a = 42;

a &amp;&amp; foo(); // 42</code></pre>
</section><section><h3 id="compare-implicit-and-explicit">Compare Implicit and Explicit</h3>
<pre><code class="lang-js">
var a = 42;
var b = null;
var c = &quot;foo&quot;;

if (a &amp;&amp; (b || c)) {
    console.log( &quot;yep&quot; );
}

//or

if (!!a &amp;&amp; (!!b || !!c)) {
    console.log( &quot;yep&quot; );
}

//or

if (Boolean(a) &amp;&amp; (Boolean(b) || Boolean(c))) {
    console.log( &quot;yep&quot; );
}</code></pre>
</section><section><h3 id="symbol-coercion">Symbol Coercion</h3>
<p>Exceedingly rare for you to need to coerce a <code>symbol</code> value</p>
<pre><code class="lang-js">var s1 = Symbol( &quot;cool&quot; );
String( s1 );                    // &quot;Symbol(cool)&quot;

var s2 = Symbol( &quot;not cool&quot; );
s2 + &quot;&quot;;                        // TypeError</code></pre>
</section><section><h2 id="loose-equals-vs-strict-equals">Loose Equals vs. Strict Equals</h2>
<ol>
<li>&#39;==&#39; allows coercion</li>
<li><p>&#39;===&#39; disallow coercion</p>
</li>
<li><p>Abstract Equality</p>
</li>
<li>Edge Cases</li>
</ol>
</section><section><h3 id="abstract-equality">Abstract Equality</h3>
<p>if the two values being compared are of the same type, they are simply and naturally compared via Identity</p>
<ul>
<li><code>NaN</code> is never equal to itself</li>
<li><code>+0</code> and <code>-0</code> are equal to each other</li>
</ul>
<p>For objects(arrays, functions) references point to <em>the exact same value</em></p>
</section><section><h3 id="comparing-string-s-to-number-s">Comparing: <code>string</code>s to <code>number</code>s</h3>
<ol>
<li>x == ToNumber(y)</li>
<li>ToNumber(x) == y</li>
</ol>
<pre><code class="lang-js">var a = 42;
var b = &quot;42&quot;;

a === b;    // false
a == b;        // true</code></pre>
</section><section><h3 id="comparing-anything-to-boolean-">Comparing: anything to <code>boolean</code></h3>
<ol>
<li>x == ToNumber(y)</li>
<li>ToNumber(x) == y</li>
</ol>
<p><strong>It is not performing a boolean test/coercion</strong> at all</p>
<pre><code class="lang-js">var a = &quot;42&quot;;
var b = true;

a == b;    // false

42 == 1;   // false</code></pre>
<p>Avoid &#39;==&#39; with <code>true</code> and <code>false</code>, however <code>===</code> is ok</p>
</section><section><h3 id="comparing-null-s-to-undefined-s">Comparing: <code>null</code>s to <code>undefined</code>s</h3>
<ol>
<li>If x is null and y is undefined, return true.</li>
<li>If x is undefined and y is null, return true.</li>
</ol>
<pre><code class="lang-js">var a = null;
var b;

a == b;        // true
a == null;    // true
b == null;    // true

a == false;    // false
b == false;    // false
a == &quot;&quot;;    // false
b == &quot;&quot;;    // false
a == 0;        // false
b == 0;        // false</code></pre>
</section><section><h3 id="comparing-object-s-to-non-object-s">Comparing: <code>object</code>s to non-<code>object</code>s</h3>
<ol>
<li>x == ToPrimitive(y)</li>
<li>ToPrimitive(x) == y</li>
</ol>
<pre><code class="lang-js">var a = 42;
var b = [ 42 ];

a == b;    // true

42 == &quot;42&quot;; //true</code></pre>
</section><section><h3 id="edge-cases">Edge Cases</h3>
<p>Examined how the <em>implicit</em> coercion of <code>==</code> loose equality works</p>
</section><section><h3 id="a-number-by-any-other-value-would-">A Number By Any Other Value Would...</h3>
<pre><code class="lang-js">var i = 2;

Number.prototype.valueOf = function() {
    return i++; // an evil trick
};

var a = new Number( 42 );

if (a == 2 &amp;&amp; a == 3) {
    console.log( &quot;Yep, this happened.&quot; );
}</code></pre>
</section><section><h3 id="false-y-comparisons">False-y Comparisons</h3>
<pre><code class="lang-js">&quot;0&quot; == null;            // false
&quot;0&quot; == undefined;        // false
&quot;0&quot; == false;            // true -- UH OH!
&quot;0&quot; == NaN;                // false
&quot;0&quot; == 0;                // true
&quot;0&quot; == &quot;&quot;;                // false

false == null;            // false
false == undefined;        // false
false == NaN;            // false
false == 0;                // true -- UH OH!
false == &quot;&quot;;            // true -- UH OH!
false == [];            // true -- UH OH!
false == {};            // false

&quot;&quot; == null;                // false
&quot;&quot; == undefined;        // false
&quot;&quot; == NaN;                // false
&quot;&quot; == 0;                // true -- UH OH!
&quot;&quot; == [];                // true -- UH OH!
&quot;&quot; == {};                // false

0 == null;                // false
0 == undefined;            // false
0 == NaN;                // false
0 == [];                // true -- UH OH!
0 == {};                // false</code></pre>
</section><section><h3 id="the-crazy-ones">The Crazy Ones</h3>
<pre><code class="lang-js">[] == ![];        // true
[] == false;    // true

2 == [2];       // true
&quot;&quot; == [null]    // true

0 == &quot;\n&quot;;        // true</code></pre>
</section><section><h3 id="reasonable-examples">Reasonable examples</h3>
<pre><code class="lang-js">42 == &quot;43&quot;;                            // false
&quot;foo&quot; == 42;                        // false
&quot;true&quot; == true;                        // false

42 == &quot;42&quot;;                            // true
&quot;foo&quot; == [ &quot;foo&quot; ];                    // true</code></pre>
</section><section><h3 id="sanity-check">Sanity Check</h3>
<pre><code class="lang-js">
&quot;0&quot; == false;            // true -- UH OH!
false == 0;                // true -- UH OH!
false == &quot;&quot;;            // true -- UH OH!
false == [];            // true -- UH OH!


&quot;&quot; == 0;                // true -- UH OH!
&quot;&quot; == [];                // true -- UH OH!
0 == [];                // true -- UH OH!</code></pre>
<ol>
<li>If either side of the comparison can have <code>true</code> or <code>false</code> values, don&#39;t ever, EVER use <code>==</code>.</li>
<li>If either side of the comparison can have <code>[]</code>, <code>&quot;&quot;</code>, or <code>0</code> values, seriously consider not using <code>==</code>.</li>
</ol>
</section><section><h3 id="javascript-equality-table">JavaScript Equality Table</h3>
<p><a href="https://github.com/dorey/JavaScript-Equality-Table">https://github.com/dorey/JavaScript-Equality-Table</a></p>
</section><section><h2 id="abstract-relational-comparison">Abstract Relational Comparison</h2>
<ol>
<li>Convert with <code>ToNumber</code></li>
<li>If both <code>strings</code> use simple lexicographic comparasion</li>
</ol>
<pre><code class="lang-js">var a = [ 42 ];
var b = [ &quot;43&quot; ];

a &lt; b;    // true
b &lt; a;    // false

var a1 = [ &quot;42&quot; ];
var b1 = [ &quot;043&quot; ];

a1 &lt; b1;    // false

var a2 = [ 4, 2 ];
var b2 = [ 0, 4, 3 ];

a2 &lt; b2;    // false

var a3 = [ 42 ];
var b3 = &quot;043&quot;;

a3 &lt; b3;                        // false -- string comparison!
Number( a ) &lt; Number( b );        // true -- number comparison!</code></pre>
</section><section><h2 id="review">Review</h2>
<ol>
<li>Coercions can be characterized as explicit or implicit</li>
<li>Important task for the responsible JS developer is to take the time to learn all the ins and outs of coercion</li>
<li><em>Explicit</em> coercion is code which is obvious that the intent is to convert a value from one type to another</li>
<li><em>Implicit</em> coercion is coercion that is &quot;hidden&quot; as a side-effect of some other operation</li>
<li><em>Implicit</em> coercion is also about improving the readability of code</li>
</ol>
</section>
			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,
                slideNumber: true,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

				// Parallax scrolling
				// parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
				// parallaxBackgroundSize: '2100px 900px',

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});

		</script>

	</body>
</html>
